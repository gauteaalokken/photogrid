<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fotogrid Pro V1.0</title>
    <meta name="description" content="Profesjonelt verktøy for å lage bildegrid for utskrift og sosiale medier.">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        :root {
            /* Farger */
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-app: #f3f4f6;
            --bg-panel: #ffffff;
            --text-main: #111827;
            --text-muted: #6b7280;
            --border: #e5e7eb;
            --danger: #ef4444;
            --success-bg: #ecfdf5;
            --success-text: #065f46;
            
            /* Dimensjoner */
            --sidebar-width: 320px;
            --depot-height: 140px;
        }

        /* Nullstilling & Base */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            height: 100vh; 
            overflow: hidden; 
            background: var(--bg-app); 
            color: var(--text-main); 
        }

        /* CSS Grid Layout - App Shell */
        .app-shell {
            display: grid;
            grid-template-areas: "sidebar main" "sidebar depot";
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-rows: 1fr var(--depot-height);
            height: 100vh;
            width: 100vw;
        }

        /* --- SIDEBAR --- */
        .sidebar {
            grid-area: sidebar;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            z-index: 20;
        }
        .sidebar-header { padding: 20px; border-bottom: 1px solid var(--border); }
        .sidebar-header h1 { font-size: 20px; font-weight: 700; margin-bottom: 10px; }
        
        .layout-tabs { display: flex; gap: 5px; background: var(--bg-app); padding: 4px; border-radius: 8px; }
        .tab-btn {
            flex: 1; border: none; padding: 6px; font-size: 12px; font-weight: 600;
            background: transparent; color: var(--text-muted); cursor: pointer; border-radius: 6px;
        }
        .tab-btn.active { background: white; color: var(--primary); box-shadow: 0 1px 2px rgba(0,0,0,0.1); }

        .sidebar-content { padding: 20px; display: flex; flex-direction: column; gap: 20px; }

        /* Skjemakontroller */
        fieldset { border: 0; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 12px; }
        legend { font-weight: 600; font-size: 13px; text-transform: uppercase; color: var(--text-muted); margin-bottom: 8px; }
        
        .control-group { display: flex; flex-direction: column; gap: 6px; }
        label { font-size: 13px; font-weight: 500; display: flex; justify-content: space-between; }
        
        input[type="text"], select {
            width: 100%; padding: 8px 10px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px;
        }
        input[type="range"] { width: 100%; cursor: pointer; }

        /* Knapper */
        .btn { width: 100%; padding: 10px; border-radius: 6px; border: 1px solid transparent; cursor: pointer; font-weight: 500; font-size: 13px; transition: all 0.2s; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-secondary { background: white; border-color: var(--border); color: var(--text-main); }
        .btn-secondary:hover { background: var(--bg-app); }
        .btn-secondary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-danger { color: var(--danger); border-color: #fecaca; background: #fef2f2; }
        
        .btn-group { display: flex; gap: 8px; }
        .toggle-btn { flex: 1; padding: 6px; background: white; border: 1px solid var(--border); border-radius: 6px; cursor: pointer; }
        .toggle-btn.active { background: #eff6ff; border-color: var(--primary); color: var(--primary); }

        /* Visuell fokus for tilgjengelighet */
        *:focus-visible { outline: 2px solid var(--primary); outline-offset: 2px; }

        /* --- MAIN AREA --- */
        .main-area {
            grid-area: main;
            background: var(--bg-app);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .canvas-scroller {
            flex: 1; overflow-x: auto; overflow-y: hidden;
            display: flex; align-items: center; padding: 40px; gap: 20px;
        }

        /* --- SIDER --- */
        .page-wrapper {
            display: flex; flex-direction: column; align-items: center; flex-shrink: 0;
            transition: transform 0.2s; position: relative;
        }
        .page-wrapper.active { transform: scale(1.02); z-index: 10; }
        
        .page-header { width: 100%; display: flex; justify-content: space-between; margin-bottom: 5px; }
        .page-badge { background: white; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: bold; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        
        .canvas {
            background: white; box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            position: relative; overflow: hidden; transition: box-shadow 0.2s;
        }
        .canvas.drag-target { box-shadow: 0 0 0 4px var(--primary); }

        /* --- BILDER & CELLER --- */
        .photo-cell {
            position: absolute; background: #e5e7eb; overflow: hidden; cursor: grab;
        }
        .photo-cell img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .photo-cell.dragging { opacity: 0.5; }
        
        .warn-icon {
            position: absolute; bottom: 5px; left: 5px; background: rgba(255,255,255,0.9);
            border-radius: 4px; padding: 2px 5px; font-size: 12px; cursor: help; display: flex; gap: 4px; align-items: center;
        }

        .remove-btn {
            position: absolute; top: 5px; right: 5px; width: 22px; height: 22px;
            background: rgba(220, 38, 38, 0.9); color: white; border: none; border-radius: 50%;
            cursor: pointer; opacity: 0; transition: opacity 0.2s; display: flex; align-items: center; justify-content: center;
        }
        .photo-cell:hover .remove-btn, .depot-item:focus-within .remove-btn, .photo-cell:focus-within .remove-btn { opacity: 1; }

        /* --- DEPOT --- */
        .depot-area {
            grid-area: depot;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            display: flex; flex-direction: column; z-index: 30;
        }
        .depot-header {
            padding: 8px 20px; font-size: 11px; font-weight: 700; text-transform: uppercase;
            color: var(--text-muted); background: #f9fafb; border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between;
        }
        .depot-content {
            flex: 1; overflow-x: auto; padding: 10px 20px; display: flex; gap: 10px; align-items: center;
        }
        .depot-content.drag-over { background: #eff6ff; }
        
        .depot-item {
            width: 80px; height: 80px; flex-shrink: 0; border-radius: 6px; overflow: hidden;
            border: 1px solid var(--border); position: relative; cursor: grab; background: white;
        }
        .depot-item:focus { outline: 2px solid var(--primary); }

        /* --- UTILITIES --- */
        .hidden { display: none !important; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }
        
        /* Insert Zone */
        .insert-zone { width: 40px; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.2s; }
        .insert-zone:hover, .insert-zone:focus-within { opacity: 1; }
        .btn-insert { width: 32px; height: 32px; border-radius: 50%; background: var(--primary); color: white; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; }

        /* Mobil Responsivitet */
        @media (max-width: 900px) {
            .app-shell { 
                grid-template-areas: "main" "depot"; 
                grid-template-columns: 1fr; 
                grid-template-rows: 1fr 120px; 
            }
            .sidebar { 
                position: fixed; inset: 0; z-index: 50; 
                transform: translateX(-100%); transition: transform 0.3s; 
            }
            .sidebar.open { transform: translateX(0); }
            .mobile-toggle { display: block; position: absolute; top: 10px; left: 10px; z-index: 40; }
        }
        @media (min-width: 901px) { .mobile-toggle { display: none; } }
    </style>
</head>
<body>

<div class="app-shell">

    <button class="mobile-toggle btn-secondary" onclick="document.querySelector('.sidebar').classList.toggle('open')" aria-label="Åpne meny">☰ Meny</button>

    <aside class="sidebar" aria-label="Kontrollpanel">
        <div class="sidebar-header">
            <h1>Fotogrid Pro</h1>
            <nav class="layout-tabs" aria-label="Velg layout type">
                <button class="tab-btn active" aria-pressed="true">Standard</button>
                <button class="tab-btn" aria-pressed="false" onclick="alert('Kommer snart')">Kollasj</button>
                <button class="tab-btn" aria-pressed="false" onclick="alert('Kommer snart')">Friform</button>
            </nav>
        </div>

        <form class="sidebar-content" onsubmit="event.preventDefault();">
            <div class="control-group">
                <button type="button" class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                    <span aria-hidden="true">+</span> Last opp bilder
                </button>
                <input type="file" id="fileInput" multiple accept="image/*" class="hidden">
                <div id="uploadStatus" role="status" style="font-size: 12px; color: var(--text-muted); margin-top: 5px;">
                    Antall bilder: <span id="photoCount">0</span>
                </div>
            </div>

            <fieldset>
                <legend>Prosjektinnstillinger</legend>
                <div class="control-group">
                    <label for="projectName">Prosjektnavn</label>
                    <input type="text" id="projectName" placeholder="Mitt Prosjekt" autocomplete="off">
                </div>
                <div class="control-group">
                    <label for="paperSize">Papirstørrelse</label>
                    <select id="paperSize">
                        <option value="A4">A4 (210x297mm)</option>
                        <option value="A3">A3 (297x420mm)</option>
                        <option value="PHOTO_10X15">10x15 Foto</option>
                        <option value="INSTASTORY">Instagram Story</option>
                    </select>
                </div>
                <div class="control-group">
                    <label id="orientLabel">Orientering</label>
                    <div class="btn-group" role="group" aria-labelledby="orientLabel">
                        <button type="button" id="btnPortrait" class="toggle-btn active" aria-pressed="true">Stående</button>
                        <button type="button" id="btnLandscape" class="toggle-btn" aria-pressed="false">Liggende</button>
                    </div>
                </div>
            </fieldset>

            <hr style="border: 0; border-top: 1px solid var(--border);">

            <fieldset>
                <legend>Grid & Layout</legend>
                
                <div class="control-group">
                    <label for="photosPerPage">Bilder pr side: <output id="outPhotosPerPage">10</output></label>
                    <input type="range" id="photosPerPage" min="1" max="50" value="10">
                </div>

                <div class="control-group">
                    <label for="margin">Margin (mm): <output id="outMargin">5</output></label>
                    <input type="range" id="margin" min="0" max="50" value="5">
                </div>

                <div class="control-group">
                    <label for="gap">Avstand (mm): <output id="outGap">2</output></label>
                    <input type="range" id="gap" min="0" max="20" value="2">
                </div>

                <div class="control-group">
                    <label for="bgColor">Bakgrunn</label>
                    <div style="display: flex; gap: 5px;">
                        <input type="color" id="bgColor" value="#FFFFFF" style="width:40px; height:36px; padding:0;">
                        <input type="text" id="bgColorText" value="#FFFFFF" readonly>
                    </div>
                </div>
            </fieldset>

            <div style="margin-top: auto; display: flex; flex-direction: column; gap: 10px;">
                <button type="button" class="btn btn-secondary" id="autoFlowBtn" title="Omorganiser alle bilder automatisk">Nullstill (Autoflow)</button>
                <button type="button" class="btn btn-secondary" id="undoBtn" disabled aria-keyshortcuts="Control+Z">Angre (Ctrl+Z)</button>
                
                <div style="display:flex; gap:5px; align-items:end;">
                    <div style="flex:1">
                        <label for="dpi" style="font-size:10px; margin-bottom:2px;">Kvalitet (DPI)</label>
                        <select id="dpi" style="padding:6px;"><option value="150">150 (Rask)</option><option value="300" selected>300 (Print)</option></select>
                    </div>
                    <button type="button" class="btn btn-secondary" id="exportBtn" style="flex:2; background:var(--success-bg); border-color:#6ee7b7; color:var(--success-text); font-weight:600;">
                        Last ned JPG
                    </button>
                </div>
                <button type="button" class="btn btn-danger" id="resetAllBtn">Slett alt</button>
            </div>
        </form>
    </aside>

    <main class="main-area" id="mainArea">
        <div id="toast" role="alert" aria-live="polite" style="position: absolute; top: 20px; right: 20px; background: white; padding: 8px 16px; border-radius: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); font-weight: 600; transform: translateY(-100px); transition: transform 0.3s; z-index: 100;">
            Status melding
        </div>
        
        <div class="canvas-scroller" id="canvasWrapper">
            </div>
    </main>

    <section class="depot-area" aria-label="Bilde depot">
        <div class="depot-header">
            <span>Bilde-depot (Mellomlagring)</span>
            <span id="depotCount">0 bilder</span>
        </div>
        <div class="depot-content" id="depotContainer" tabindex="0" aria-label="Liste over bilder i depotet. Bruk pilene for å navigere.">
            <div class="empty-msg" style="width:100%; text-align:center; color:var(--text-muted); font-style:italic; font-size:13px;">Dra bilder hit for å spare dem</div>
        </div>
    </section>

</div>

<script>
/** * --- KONFIGURASJON & WORKER --- 
 */
const CONFIG = {
    PAPER: {
        A4: { w: 210, h: 297 }, A3: { w: 297, h: 420 },
        PHOTO_10X15: { w: 100, h: 150 }, INSTASTORY: { w: 108, h: 192 }
    },
    HISTORY_LIMIT: 20
};

// Web Worker Code (Inline for single-file portability)
const WORKER_SCRIPT = `
self.onmessage = async (e) => {
    const { type, payload } = e.data;
    if (type === 'EXPORT') {
        const { pages, width, height, bgColor, dpi, quality } = payload;
        const results = [];
        
        try {
            const offCanvas = new OffscreenCanvas(width, height);
            const ctx = offCanvas.getContext('2d');

            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                
                // Clear & BG
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, width, height);
                
                // Draw Photos
                for (const cell of page.cells) {
                    const bitmap = await createImageBitmap(cell.blob);
                    
                    // Object-fit: cover logic
                    const imgRatio = bitmap.width / bitmap.height;
                    const targetRatio = cell.w / cell.h;
                    let sx=0, sy=0, sw=bitmap.width, sh=bitmap.height;
                    
                    if (imgRatio > targetRatio) {
                        sw = sh * targetRatio; sx = (bitmap.width - sw) / 2;
                    } else {
                        sh = sw / targetRatio; sy = (bitmap.height - sh) / 2;
                    }

                    ctx.drawImage(bitmap, sx, sy, sw, sh, cell.x, cell.y, cell.w, cell.h);
                }

                const blob = await offCanvas.convertToBlob({ type: 'image/jpeg', quality: 0.95 });
                results.push(blob);
                self.postMessage({ type: 'PROGRESS', current: i + 1, total: pages.length });
            }
            self.postMessage({ type: 'COMPLETE', blobs: results });
        } catch (err) {
            self.postMessage({ type: 'ERROR', message: err.message });
        }
    }
};
`;

/**
 * --- CLASSES ---
 */

class Utils {
    static uuid() { return Math.random().toString(36).substr(2, 9); }
    
    static debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    static validateRes(originalW, renderW, paperW, dpi) {
        // Beregn faktisk mm-bredde av bildet på papiret
        const mmPerPx = paperW / 1000; // Forenklet ratio, justeres i render
        const actualWidthMM = (renderW / paperW) * paperW; // renderW er px på skjerm, men vi trenger forholdet
        // Egentlig: Vi vet hvor stor andel av bredden bildet tar
        const ratio = renderW; // renderW er allerede i 'grid units' som tilsvarer tilgjengelig bredde
        // La oss si renderW er piksler på skjermen. Vi må vite forholdet.
        // Enklere: Hvis vi skal printe 300 DPI, trenger vi ca 11.8 px per mm.
        const requiredPx = (renderW / 25.4) * dpi; // Dette blir feil fordi renderW er skjerm-px.
        // Vi lar Renderer håndtere dette da den vet skaleringen.
        return true; 
    }
}

class StateManager {
    constructor() {
        this.photos = new Map(); // id -> {id, file, blobUrl, w, h, ratio}
        this.pages = [[]]; // Array of Arrays of IDs
        this.depot = []; // Array of IDs
        
        this.settings = {
            projectName: '', paperSize: 'A4', orientation: 'portrait',
            perPage: 10, margin: 5, gap: 2, bgColor: '#FFFFFF'
        };

        this.history = [];
        this.historyPointer = -1;
        this.listeners = [];
    }

    subscribe(cb) { this.listeners.push(cb); }
    notify() { this.listeners.forEach(cb => cb()); }

    pushState() {
        // Remove future if we are in past
        if (this.historyPointer < this.history.length - 1) {
            this.history = this.history.slice(0, this.historyPointer + 1);
        }
        
        const snapshot = JSON.parse(JSON.stringify({
            pages: this.pages,
            depot: this.depot,
            settings: this.settings
        }));

        this.history.push(snapshot);
        if (this.history.length > CONFIG.HISTORY_LIMIT) this.history.shift();
        else this.historyPointer++;
        
        this.notify();
    }

    undo() {
        if (this.historyPointer > 0) {
            this.historyPointer--;
            const state = JSON.parse(JSON.stringify(this.history[this.historyPointer]));
            this.pages = state.pages;
            this.depot = state.depot;
            this.settings = state.settings; // Restore sliders too
            this.notify();
            return true;
        }
        return false;
    }

    addPhotos(fileList) {
        this.pushState();
        const promises = fileList.map(file => {
            return new Promise(resolve => {
                const img = new Image();
                const url = URL.createObjectURL(file);
                img.onload = () => {
                    const asset = {
                        id: Utils.uuid(),
                        file: file, // Keep file for worker
                        src: url,
                        w: img.width, h: img.height,
                        ratio: img.width / img.height
                    };
                    this.photos.set(asset.id, asset);
                    resolve(asset.id);
                };
                img.src = url;
            });
        });

        Promise.all(promises).then(ids => {
            // Add to current page or new page
            const currPage = this.pages[this.pages.length - 1];
            this.pages[this.pages.length - 1] = [...currPage, ...ids];
            this.autoFlow(); // Redistribute
        });
    }

    autoFlow() {
        const allIds = this.pages.flat();
        const limit = this.settings.perPage;
        const newPages = [];
        for (let i = 0; i < allIds.length; i += limit) {
            newPages.push(allIds.slice(i, i + limit));
        }
        if (newPages.length === 0) newPages.push([]);
        this.pages = newPages;
        this.notify();
    }

    deletePhoto(id) {
        this.pushState();
        this.pages = this.pages.map(p => p.filter(x => x !== id));
        this.depot = this.depot.filter(x => x !== id);
        this.photos.delete(id);
        this.notify();
    }

    movePhoto(id, from, to) {
        this.pushState();
        // Remove
        if (from.type === 'depot') this.depot = this.depot.filter(x => x !== id);
        else this.pages[from.idx] = this.pages[from.idx].filter(x => x !== id);

        // Add
        if (to.type === 'depot') this.depot.push(id);
        else this.pages[to.idx].push(id);
        
        this.notify();
    }

    insertPage(index) {
        this.pushState();
        this.pages.splice(index, 0, []);
        this.notify();
    }

    removePage(index) {
        this.pushState();
        const pIds = this.pages[index];
        pIds.forEach(id => this.photos.delete(id)); // Delete photos permanently
        this.pages.splice(index, 1);
        if(this.pages.length === 0) this.pages.push([]);
        this.notify();
    }
    
    wipe() {
        this.pushState();
        this.pages = [[]];
        this.depot = [];
        this.photos.clear();
        this.notify();
    }
}

class LayoutEngine {
    static calculate(ids, photosMap, width, gap) {
        if (!ids.length) return { cells: [], height: 0 };
        
        // Forenklet "Row Balance" algoritme
        const rows = [];
        const idealHeight = width / 3; // Start gjetning
        let currentRow = [];
        let currentWidth = 0;

        // 1. Group into rows
        for (const id of ids) {
            const p = photosMap.get(id);
            if(!p) continue;
            
            // Scaled width if height was 100
            const w = 100 * p.ratio;
            currentRow.push({ ...p, scaledW: w });
            currentWidth += w;

            // Check if row is full enough
            if (currentWidth > (width / idealHeight * 100) || currentRow.length >= 5) {
                rows.push(currentRow);
                currentRow = [];
                currentWidth = 0;
            }
        }
        if (currentRow.length) rows.push(currentRow);

        // 2. Calculate coordinates
        const cells = [];
        let y = 0;
        
        rows.forEach(row => {
            // Calculate scale factor to fill width
            const aspectSum = row.reduce((sum, item) => sum + item.ratio, 0);
            const gaps = (row.length - 1) * gap;
            const rowHeight = (width - gaps) / aspectSum;
            
            let x = 0;
            row.forEach(item => {
                const w = rowHeight * item.ratio;
                cells.push({
                    id: item.id, x, y, width: w, height: rowHeight,
                    photo: item // Ref for checking resolution
                });
                x += w + gap;
            });
            y += rowHeight + gap;
        });

        return { cells, height: y };
    }
}

class App {
    constructor() {
        this.state = new StateManager();
        
        // DOM Elements
        this.dom = {
            wrapper: document.getElementById('canvasWrapper'),
            depot: document.getElementById('depotContainer'),
            inputs: {
                perPage: document.getElementById('photosPerPage'),
                margin: document.getElementById('margin'),
                gap: document.getElementById('gap'),
                bg: document.getElementById('bgColor'),
                project: document.getElementById('projectName')
            }
        };

        // Worker Init
        const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });
        this.worker = new Worker(URL.createObjectURL(blob));
        this.worker.onmessage = this.handleWorkerMsg.bind(this);

        this.bindEvents();
        this.state.subscribe(() => this.render());
        
        // Init
        this.state.pushState(); // Initial state
    }

    bindEvents() {
        const s = this.state;
        
        // Inputs
        const bindInput = (el, key, isNum=false) => {
            el.addEventListener('input', Utils.debounce(e => {
                s.settings[key] = isNum ? parseFloat(e.target.value) : e.target.value;
                document.getElementById('out' + el.id.charAt(0).toUpperCase() + el.id.slice(1))?.setAttribute('value', el.value);
                if(key === 'perPage') s.autoFlow();
                else s.notify(); // Trigger render
            }, 50));
        };

        bindInput(this.dom.inputs.perPage, 'perPage', true);
        bindInput(this.dom.inputs.margin, 'margin', true);
        bindInput(this.dom.inputs.gap, 'gap', true);
        
        this.dom.inputs.bg.addEventListener('input', (e) => {
            s.settings.bgColor = e.target.value;
            document.getElementById('bgColorText').value = e.target.value;
            s.notify();
        });

        this.dom.inputs.project.addEventListener('change', e => s.settings.projectName = e.target.value);

        // Buttons
        document.getElementById('btnPortrait').onclick = () => this.setOri('portrait');
        document.getElementById('btnLandscape').onclick = () => this.setOri('landscape');
        document.getElementById('autoFlowBtn').onclick = () => s.autoFlow();
        document.getElementById('undoBtn').onclick = () => s.undo();
        document.getElementById('resetAllBtn').onclick = () => confirm('Slette alt?') && s.wipe();
        document.getElementById('exportBtn').onclick = () => this.export();
        
        // File Upload
        document.getElementById('fileInput').onchange = (e) => {
            if(e.target.files.length) s.addPhotos(Array.from(e.target.files));
            e.target.value = '';
        };

        // Keyboard Undo
        document.addEventListener('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault(); s.undo();
            }
        });

        // Drag & Drop
        this.setupDragDrop();
    }

    setOri(o) {
        this.state.settings.orientation = o;
        document.getElementById('btnPortrait').classList.toggle('active', o === 'portrait');
        document.getElementById('btnPortrait').setAttribute('aria-pressed', o === 'portrait');
        document.getElementById('btnLandscape').classList.toggle('active', o === 'landscape');
        document.getElementById('btnLandscape').setAttribute('aria-pressed', o === 'landscape');
        this.state.notify();
    }

    render() {
        const { pages, depot, settings, photos } = this.state;
        const wrapper = this.dom.wrapper;
        
        // Update Undo Btn
        document.getElementById('undoBtn').disabled = this.state.historyPointer <= 0;
        document.getElementById('photoCount').textContent = photos.size;

        // Dimensions
        const size = CONFIG.PAPER[settings.paperSize];
        const isPort = settings.orientation === 'portrait';
        const paperW = isPort ? size.w : size.h;
        const paperH = isPort ? size.h : size.w;
        const ratio = paperW / paperH;

        // Render Params
        const viewH = wrapper.clientHeight - 80;
        const viewW = viewH * ratio;
        const scale = viewW / paperW; // px per mm
        const marginPx = settings.margin * scale;
        const gapPx = settings.gap * scale;

        // Render Pages
        wrapper.innerHTML = '';
        
        // Prepend Insert Zone
        wrapper.appendChild(this.createInsertZone(0));

        pages.forEach((pageIds, idx) => {
            const pageDiv = document.createElement('div');
            pageDiv.className = 'page-wrapper';
            pageDiv.innerHTML = `
                <div class="page-header">
                    <span class="page-badge">Side ${idx + 1}</span>
                    <button class="btn-secondary" style="width:auto; padding:2px 8px; font-size:11px;" onclick="app.state.removePage(${idx})" title="Slett side">Slett</button>
                </div>
                <div class="canvas" data-type="page" data-idx="${idx}" style="width:${viewW}px; height:${viewH}px; background:${settings.bgColor};"></div>
            `;
            
            const canvas = pageDiv.querySelector('.canvas');
            
            // Grid Layout
            const availW = viewW - (2 * marginPx);
            const availH = viewH - (2 * marginPx);
            const layout = LayoutEngine.calculate(pageIds, photos, availW, gapPx);
            
            // Center grid vertically
            const offsetY = (availH - layout.height) / 2;

            layout.cells.forEach(cell => {
                const p = photos.get(cell.id);
                const el = document.createElement('div');
                el.className = 'photo-cell';
                el.draggable = true;
                el.dataset.id = cell.id;
                // Position relative to margin + offset
                el.style.left = (marginPx + cell.x) + 'px';
                el.style.top = (marginPx + offsetY + cell.y) + 'px';
                el.style.width = cell.width + 'px';
                el.style.height = cell.height + 'px';
                
                // Resolution Check
                const dpi = parseInt(document.getElementById('dpi').value);
                const mmW = (cell.width / scale); // Width in MM
                const neededPx = (mmW / 25.4) * dpi;
                const lowRes = p.w < neededPx;

                el.innerHTML = `
                    <img src="${p.src}">
                    <button class="remove-btn" onclick="app.state.deletePhoto('${cell.id}')">×</button>
                    ${lowRes ? `<div class="warn-icon" title="Lav oppløsning for print">⚠️</div>` : ''}
                `;
                canvas.appendChild(el);
            });

            wrapper.appendChild(pageDiv);
            wrapper.appendChild(this.createInsertZone(idx + 1));
        });

        // Render Depot
        const depotEl = this.dom.depot;
        depotEl.innerHTML = depot.length ? '' : '<div class="empty-msg">Depotet er tomt</div>';
        document.getElementById('depotCount').textContent = `${depot.length}`;
        
        depot.forEach(id => {
            const p = photos.get(id);
            const el = document.createElement('div');
            el.className = 'depot-item';
            el.draggable = true;
            el.dataset.id = id;
            el.tabIndex = 0; // A11y
            el.innerHTML = `<img src="${p.src}"><button class="remove-btn" onclick="app.state.deletePhoto('${id}')">×</button>`;
            
            // Keyboard Nav: Enter to move to active page
            el.onkeydown = (e) => {
                if(e.key === 'Enter') this.state.movePhoto(id, {type:'depot'}, {type:'page', idx: this.state.pages.length-1});
            };
            
            depotEl.appendChild(el);
        });
    }

    createInsertZone(idx) {
        const div = document.createElement('div');
        div.className = 'insert-zone';
        div.innerHTML = `<button class="btn-insert" title="Sett inn ny side" onclick="app.state.insertPage(${idx})">+</button>`;
        return div;
    }

    setupDragDrop() {
        let draggedId = null;
        let source = null;

        document.addEventListener('dragstart', e => {
            const target = e.target.closest('.photo-cell, .depot-item');
            if(!target) return;
            draggedId = target.dataset.id;
            target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            
            const pPage = target.closest('.canvas');
            if(pPage) source = { type: 'page', idx: parseInt(pPage.dataset.idx) };
            else source = { type: 'depot' };
        });

        document.addEventListener('dragend', () => {
            document.querySelectorAll('.dragging').forEach(e => e.classList.remove('dragging'));
            document.querySelectorAll('.drag-target').forEach(e => e.classList.remove('drag-target'));
        });

        document.addEventListener('dragover', e => {
            e.preventDefault();
            const target = e.target.closest('.canvas, .depot-content');
            if(target) target.classList.add('drag-target');
        });
        
        document.addEventListener('dragleave', e => {
             const target = e.target.closest('.canvas, .depot-content');
             if(target) target.classList.remove('drag-target');
        });

        document.addEventListener('drop', e => {
            e.preventDefault();
            if(!draggedId) return;
            
            const dropPage = e.target.closest('.canvas');
            const dropDepot = e.target.closest('.depot-content');
            
            let dest = null;
            if(dropPage) dest = { type: 'page', idx: parseInt(dropPage.dataset.idx) };
            else if(dropDepot) dest = { type: 'depot' };

            if(dest) {
                this.state.movePhoto(draggedId, source, dest);
            }
            draggedId = null;
        });
    }

    export() {
        if(this.state.photos.size === 0) return alert("Ingen bilder å eksportere");
        
        const btn = document.getElementById('exportBtn');
        btn.disabled = true;
        btn.textContent = "Forbereder...";
        
        const s = this.state.settings;
        const size = CONFIG.PAPER[s.paperSize];
        const isPort = s.orientation === 'portrait';
        const mmW = isPort ? size.w : size.h;
        const mmH = isPort ? size.h : size.w;
        
        const dpi = parseInt(document.getElementById('dpi').value);
        const pxW = Math.round((mmW / 25.4) * dpi);
        const pxH = Math.round((mmH / 25.4) * dpi);
        const gapPx = (s.gap / 25.4) * dpi;
        const marginPx = (s.margin / 25.4) * dpi;

        // Prepare data for worker (Coordinate calculations must happen here or be duplicated)
        // We calculate layout again using the print dimensions
        const pagesPayload = this.state.pages.map(pageIds => {
             const layout = LayoutEngine.calculate(pageIds, this.state.photos, pxW - (2*marginPx), gapPx);
             // Adjust coordinates for margin and center vertical
             const offsetY = (pxH - (2*marginPx) - layout.height) / 2;
             
             return {
                 cells: layout.cells.map(c => ({
                     blob: this.state.photos.get(c.id).file,
                     x: Math.round(c.x + marginPx),
                     y: Math.round(c.y + marginPx + offsetY),
                     w: Math.round(c.width),
                     h: Math.round(c.height)
                 }))
             };
        });

        this.worker.postMessage({
            type: 'EXPORT',
            payload: {
                pages: pagesPayload,
                width: pxW, height: pxH,
                bgColor: s.bgColor,
                dpi: dpi
            }
        });
    }

    handleWorkerMsg(e) {
        const { type, blobs, current, total } = e.data;
        const btn = document.getElementById('exportBtn');
        const toast = document.getElementById('toast');

        if (type === 'PROGRESS') {
            btn.textContent = `Genererer ${current}/${total}...`;
        } else if (type === 'COMPLETE') {
            btn.textContent = "Last ned JPG";
            btn.disabled = false;
            
            // Show toast
            toast.textContent = "Eksport fullført!";
            toast.style.transform = "translateY(0)";
            setTimeout(() => toast.style.transform = "translateY(-100px)", 3000);

            // Zip or Single
            if (blobs.length === 1) {
                this.download(blobs[0], `${this.state.settings.projectName || 'Grid'}.jpg`);
            } else {
                const zip = new JSZip();
                blobs.forEach((b, i) => zip.file(`Side-${i+1}.jpg`, b));
                zip.generateAsync({type:"blob"}).then(content => {
                    this.download(content, "Fotogrid-Export.zip");
                });
            }
        }
    }

    download(blob, name) {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = name;
        a.click();
        URL.revokeObjectURL(a.href);
    }
}

// Start App
const app = new App();

</script>
</body>
</html>
