<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fotogrid Pro V1.0 - Arkitekt</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <style>
        :root {
            /* Farger og Tema */
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-app: #e5e7eb;
            --bg-panel: #ffffff;
            --text-main: #111827;
            --text-muted: #6b7280;
            --border: #d1d5db;
            --danger: #ef4444;
            
            /* Dimensjoner */
            --sidebar-width: 340px;
            --depot-height: 140px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; height: 100vh; overflow: hidden; background: var(--bg-app); color: var(--text-main); }
        
        /* Layout Grid */
        .app-shell {
            display: grid;
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-rows: 1fr var(--depot-height);
            height: 100vh;
            width: 100vw;
        }

        /* Sidebar */
        .sidebar {
            grid-row: 1 / -1;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            z-index: 20;
        }
        .sidebar-header { padding: 20px; border-bottom: 1px solid var(--border); }
        .sidebar-header h1 { font-size: 20px; font-weight: 700; color: var(--text-main); }
        .sidebar-content { padding: 20px; display: flex; flex-direction: column; gap: 18px; }

        /* Main Canvas Area */
        .main-area {
            grid-column: 2;
            grid-row: 1;
            background: var(--bg-app);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .canvas-scroller {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            align-items: center;
            padding: 40px;
            gap: 20px;
        }

        /* Depot Area */
        .depot-area {
            grid-column: 2;
            grid-row: 2;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 30;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.05);
        }
        .depot-header {
            padding: 8px 20px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-muted);
            background: #f9fafb;
            border-bottom: 1px solid #f3f4f6;
            display: flex; justify-content: space-between;
        }
        .depot-content {
            flex: 1;
            overflow-x: auto;
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .depot-content.drag-over { background-color: #eff6ff; }

        /* UI Components */
        .control-group { display: flex; flex-direction: column; gap: 6px; }
        .control-label { font-size: 13px; font-weight: 600; color: var(--text-main); display: flex; justify-content: space-between; }
        
        .btn { border: none; padding: 10px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-secondary { background: white; border: 1px solid var(--border); color: var(--text-main); }
        .btn-secondary:hover { background: #f9fafb; border-color: #9ca3af; }
        .btn-secondary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-icon { width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; padding: 0; }

        input[type="text"], input[type="number"], select {
            width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px;
        }

        /* Page & Grid */
        .page-container {
            display: flex; flex-direction: column; align-items: center;
            flex-shrink: 0; transition: transform 0.2s;
            position: relative;
        }
        .page-container.active { transform: scale(1.02); z-index: 10; }
        
        .page-header { width: 100%; display: flex; justify-content: space-between; margin-bottom: 5px; align-items: center; }
        .page-badge { background: white; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: bold; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        
        .canvas {
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            transition: border 0.2s, box-shadow 0.2s;
        }
        .canvas.drop-target { border: 4px solid var(--primary); }

        .photo-cell {
            position: absolute;
            background: #e5e7eb;
            overflow: hidden;
            cursor: grab;
            transition: opacity 0.2s;
        }
        .photo-cell img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .photo-cell.dragging { opacity: 0.4; }
        
        /* Remove Button Overlay */
        .remove-btn {
            position: absolute; top: 4px; right: 4px;
            width: 20px; height: 20px;
            background: rgba(239, 68, 68, 0.9); color: white;
            border-radius: 50%; border: none; cursor: pointer;
            opacity: 0; transition: opacity 0.2s;
            display: flex; align-items: center; justify-content: center; font-size: 12px;
        }
        .photo-cell:hover .remove-btn, .depot-item:hover .remove-btn { opacity: 1; }

        /* Depot Items */
        .depot-item {
            width: 80px; height: 80px; flex-shrink: 0;
            border-radius: 6px; overflow: hidden;
            border: 1px solid var(--border);
            position: relative; cursor: grab; background: white;
        }
        .depot-item img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }

        /* Helpers */
        .hidden { display: none !important; }
        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
        .modal.open { opacity: 1; pointer-events: auto; }
        .modal-box { background: white; padding: 24px; border-radius: 8px; width: 320px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }

        /* Mobile Responsive */
        @media (max-width: 900px) {
            .app-shell { grid-template-columns: 1fr; grid-template-rows: 1fr 120px; }
            .sidebar { display: none; position: absolute; inset: 0; z-index: 50; }
            .sidebar.mobile-open { display: flex; }
        }
    </style>
</head>
<body>

<div class="app-shell">
    
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h1>Fotogrid Pro <span style="font-size: 0.6em; color: var(--primary);">V1.0</span></h1>
        </div>
        <div class="sidebar-content">
            
            <div class="control-group">
                <button class="btn btn-primary" id="uploadBtn">+ Last opp bilder</button>
                <input type="file" id="fileInput" multiple accept="image/*" class="hidden">
            </div>

            <div class="control-group">
                <label class="control-label">Prosjektnavn</label>
                <input type="text" id="projectName" placeholder="Mitt Prosjekt">
            </div>

            <div class="control-group">
                <label class="control-label">Papirstørrelse</label>
                <select id="paperSize">
                    <option value="A4">A4</option>
                    <option value="A3">A3</option>
                    <option value="PHOTO_10X15">10x15 Foto</option>
                    <option value="INSTASTORY">Instagram Story</option>
                    <option value="CUSTOM">Spesial...</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">Orientering</label>
                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-secondary" style="flex:1" id="orientPortrait">Stående</button>
                    <button class="btn btn-secondary" style="flex:1" id="orientLandscape">Liggende</button>
                </div>
            </div>

            <hr style="border: 0; border-top: 1px solid var(--border);">

            <div class="control-group">
                <label class="control-label">Bilder pr side <span id="valPhotosPerPage">10</span></label>
                <input type="range" id="photosPerPage" min="1" max="50" value="10">
            </div>

            <div class="control-group">
                <label class="control-label">Margin (mm) <span id="valMargin">5</span></label>
                <input type="range" id="margin" min="0" max="50" value="5">
            </div>

            <div class="control-group">
                <label class="control-label">Mellomrom (mm) <span id="valGap">2</span></label>
                <input type="range" id="gap" min="0" max="20" value="2">
            </div>
            
            <div class="control-group">
                <label class="control-label">Bakgrunnsfarge</label>
                <div style="display:flex; gap: 5px;">
                    <input type="color" id="bgColorPicker" value="#FFFFFF" style="height: 36px; width: 40px; padding: 0;">
                    <input type="text" id="bgColorText" value="#FFFFFF">
                </div>
            </div>

            <div style="margin-top: auto; display: flex; flex-direction: column; gap: 10px;">
                <button class="btn btn-secondary" id="autoFlowBtn">Autoflow (Nullstill sider)</button>
                <div style="display: flex; gap: 8px;">
                     <button class="btn btn-secondary" style="flex:1" id="undoBtn" disabled>Angre</button>
                     <button class="btn btn-secondary" style="flex:1" id="exportBtn">Last ned JPG</button>
                </div>
                <button class="btn btn-secondary" style="color: var(--danger); border-color: #fecaca;" id="resetAllBtn">Slett alt</button>
            </div>
        </div>
    </aside>

    <main class="main-area">
        <div id="saveStatus" style="position: absolute; top: 20px; right: 20px; background: white; padding: 5px 12px; border-radius: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); font-size: 12px; font-weight: bold; transform: translateY(-50px); transition: transform 0.3s;">Lagret</div>
        
        <div class="canvas-scroller" id="canvasWrapper">
            </div>

        <button id="toggleSidebarBtn" style="position:absolute; top:20px; left:20px; z-index:100; padding:10px; background:white; border:1px solid #ddd; border-radius:6px; display:none;">Meny</button>
    </main>

    <section class="depot-area">
        <div class="depot-header">
            <span>Bilde-depot</span>
            <span id="depotCount">0 bilder</span>
        </div>
        <div class="depot-content" id="depotContainer">
            </div>
    </section>

</div>

<div id="customSizeModal" class="modal">
    <div class="modal-box">
        <h3 style="margin-bottom: 15px;">Tilpasset Størrelse</h3>
        <div class="control-group">
            <label>Bredde (mm)</label>
            <input type="number" id="customWidth" value="200">
        </div>
        <div class="control-group" style="margin-top:10px;">
            <label>Høyde (mm)</label>
            <input type="number" id="customHeight" value="200">
        </div>
        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top: 20px;">
            <button class="btn btn-secondary" id="closeModalBtn">Avbryt</button>
            <button class="btn btn-primary" id="applyCustomBtn">Bruk</button>
        </div>
    </div>
</div>

<script>
/**
 * --- UTILITIES & CONFIG ---
 */
const CONFIG = {
    PAPER_SIZES: {
        A4: { width: 210, height: 297 },
        A3: { width: 297, height: 420 },
        PHOTO_10X15: { width: 100, height: 150 },
        INSTASTORY: { width: 108, height: 192 },
        CUSTOM: { width: 0, height: 0 }
    },
    DB_NAME: 'FotogridProDB_V1',
    DB_STORE: 'assets'
};

const Utils = {
    debounce: (func, wait) => {
        let timeout;
        return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func(...args), wait); };
    },
    uuid: () => Date.now().toString(36) + Math.random().toString(36).substr(2),
    rgbToHsl: (r, g, b) => {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) h = s = 0;
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h * 360, s, l };
    }
};

/**
 * --- STORAGE MANAGER (IndexedDB) ---
 */
class StorageManager {
    constructor() {
        this.db = null;
    }

    async init() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(CONFIG.DB_NAME, 1);
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(CONFIG.DB_STORE)) {
                    db.createObjectStore(CONFIG.DB_STORE, { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains('settings')) {
                    db.createObjectStore('settings', { keyPath: 'key' });
                }
            };
            req.onsuccess = (e) => { this.db = e.target.result; resolve(); };
            req.onerror = (e) => reject(e);
        });
    }

    async saveAsset(asset) {
        if (!this.db) return;
        this.db.transaction([CONFIG.DB_STORE], 'readwrite').objectStore(CONFIG.DB_STORE).put(asset);
    }

    async deleteAsset(id) {
        if (!this.db) return;
        this.db.transaction([CONFIG.DB_STORE], 'readwrite').objectStore(CONFIG.DB_STORE).delete(id);
    }

    async loadAssets() {
        if (!this.db) return [];
        return new Promise(resolve => {
            const tx = this.db.transaction([CONFIG.DB_STORE], 'readonly');
            const req = tx.objectStore(CONFIG.DB_STORE).getAll();
            req.onsuccess = () => resolve(req.result);
        });
    }

    async saveSettings(settings) {
        if (!this.db) return;
        // Vi lagrer kun en enkel JSON-dump av innstillingene
        const safeSettings = JSON.parse(JSON.stringify(settings));
        this.db.transaction(['settings'], 'readwrite').objectStore('settings').put({ key: 'main', val: safeSettings });
    }

    async loadSettings() {
        if (!this.db) return null;
        return new Promise(resolve => {
            const req = this.db.transaction(['settings'], 'readonly').objectStore('settings').get('main');
            req.onsuccess = () => resolve(req.result ? req.result.val : null);
        });
    }

    async clearAll() {
        if(!this.db) return;
        const tx = this.db.transaction([CONFIG.DB_STORE, 'settings'], 'readwrite');
        tx.objectStore(CONFIG.DB_STORE).clear();
        tx.objectStore('settings').clear();
        return new Promise(resolve => tx.oncomplete = resolve);
    }
}

/**
 * --- LAYOUT ENGINE (Pure Math) ---
 */
class LayoutEngine {
    static calculateGrid(photos, containerWidth, containerHeight, gap) {
        if (!photos || photos.length === 0) return { cells: [], height: 0 };
        
        let bestLayout = null;
        let bestScore = Infinity;

        // Prøv rader fra 1 til N for å finne best 'fit'
        for (let r = 1; r <= photos.length; r++) {
            const layout = this._createRows(photos, r, containerWidth, gap);
            const contentHeight = layout.naturalHeight;
            const targetHeight = containerHeight;
            
            // Beregn score basert på hvor godt det fyller høyden uten å skalere for mye
            const scale = targetHeight / contentHeight;
            let score;
            
            // Vi ønsker helst scale nær 1.0. 
            if (scale >= 0.85 && scale <= 1.15) score = Math.abs(1 - scale); 
            else if (scale < 0.85) score = 100 + (0.85 - scale); // Straff for mye tomrom
            else score = 100 + (scale - 1.15); // Straff for å måtte krympe for mye
            
            if (score < bestScore) {
                bestScore = score;
                bestLayout = { ...layout, scale };
            }
        }

        // Apply Layout
        let fitScale = bestLayout.scale;
        // Clamp scale to avoid extreme stretching
        fitScale = Math.max(0.9, Math.min(fitScale, 1.1));
        
        // Sjekk om det går utfor høyden, hvis ja, krymp til å passe
        let finalHeight = bestLayout.naturalHeight * fitScale;
        if (finalHeight > containerHeight) {
            fitScale = fitScale * (containerHeight / finalHeight);
            finalHeight = containerHeight;
        }

        const cells = [];
        let currentY = (containerHeight - finalHeight) / 2; // Sentrer vertikalt
        const finalWidth = containerWidth * fitScale;
        const startX = (containerWidth - finalWidth) / 2; // Sentrer horisontalt

        bestLayout.rows.forEach(row => {
            const rowHeight = row.baseHeight * fitScale;
            let currentX = startX;
            
            // Juster bredde på raden for gap
            const rowWidth = finalWidth - ((row.items.length - 1) * gap * fitScale);
            
            row.items.forEach(photo => {
                const width = (photo.aspectRatio / row.aspectSum) * rowWidth;
                cells.push({
                    photoId: photo.id,
                    x: currentX,
                    y: currentY,
                    width: width,
                    height: rowHeight
                });
                currentX += width + (gap * fitScale);
            });
            currentY += rowHeight + (gap * fitScale);
        });

        return { cells, height: finalHeight };
    }

    static _createRows(photos, rowCount, width, gap) {
        const rows = [];
        const basePer = Math.floor(photos.length / rowCount);
        let extra = photos.length % rowCount;
        let idx = 0;

        for (let i = 0; i < rowCount; i++) {
            const count = basePer + (i < extra ? 1 : 0);
            const items = [];
            let aspectSum = 0;
            for (let j = 0; j < count; j++) {
                if (idx < photos.length) {
                    items.push(photos[idx]);
                    aspectSum += photos[idx].aspectRatio;
                    idx++;
                }
            }
            if (items.length > 0) {
                // Høyde = (Bredde - Gaps) / AspectSum
                const totalGap = (items.length - 1) * gap;
                const h = (width - totalGap) / aspectSum;
                rows.push({ items, baseHeight: h, aspectSum });
            }
        }
        
        const totalGapH = (rows.length - 1) * gap;
        const naturalHeight = rows.reduce((acc, r) => acc + r.baseHeight, 0) + totalGapH;
        return { rows, naturalHeight };
    }
}

/**
 * --- STATE MANAGER (The Brain) ---
 */
class StateManager {
    constructor(db) {
        this.db = db;
        this.photos = new Map(); // All loaded photo assets
        this.pages = [[]];       // Array of Arrays of Photo IDs
        this.depot = [];         // Array of Photo IDs
        
        this.settings = {
            projectName: '',
            paperSize: 'A4',
            customSize: { w: 200, h: 200 },
            orientation: 'portrait',
            photosPerPage: 10,
            margin: 5,
            gap: 2,
            bgColor: '#FFFFFF'
        };

        this.history = [];
        this.listeners = [];
        this.saveTimeout = null;
    }

    subscribe(callback) { this.listeners.push(callback); }
    notify() { this.listeners.forEach(cb => cb(this)); this.scheduleSave(); }

    scheduleSave() {
        clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(() => {
            this.db.saveSettings({
                pages: this.pages,
                depot: this.depot,
                settings: this.settings
            });
            const status = document.getElementById('saveStatus');
            status.style.transform = 'translateY(0)';
            setTimeout(() => status.style.transform = 'translateY(-50px)', 1500);
        }, 1000);
    }

    pushHistory() {
        const state = JSON.stringify({ pages: this.pages, depot: this.depot });
        if (this.history.length === 0 || this.history[this.history.length-1] !== state) {
            this.history.push(state);
            if (this.history.length > 20) this.history.shift();
        }
        this.updateUndoState();
    }

    undo() {
        if (this.history.length === 0) return;
        const state = JSON.parse(this.history.pop());
        this.pages = state.pages;
        this.depot = state.depot;
        this.notify();
        this.updateUndoState();
    }

    updateUndoState() {
        const btn = document.getElementById('undoBtn');
        btn.disabled = this.history.length === 0;
        btn.textContent = this.history.length > 0 ? `Angre (${this.history.length})` : 'Angre';
    }

    // --- Actions ---

    async addPhotos(fileList) {
        this.pushHistory();
        const promises = fileList.map(file => this._processFile(file));
        const newAssets = await Promise.all(promises);
        
        // Add to global map
        newAssets.forEach(a => this.photos.set(a.id, a));
        
        // Add to current page
        const currentPageIdx = 0; // Simplified for now, could be active page
        if (this.pages.length === 0) this.pages.push([]);
        
        // Distribute to pages or just first? Let's add to first available or create new if full
        // For simplicity: Add to current visible page or last page
        this.pages[this.pages.length - 1].push(...newAssets.map(a => a.id));
        
        this.autoFlow(); // Re-distribute to look good
    }

    async _processFile(file) {
        return new Promise((resolve) => {
            const img = new Image();
            const url = URL.createObjectURL(file);
            img.onload = () => {
                // Create Tiny Thumbnail
                const scale = Math.min(1, 400 / img.width);
                const cvs = document.createElement('canvas');
                cvs.width = img.width * scale; cvs.height = img.height * scale;
                const ctx = cvs.getContext('2d');
                ctx.drawImage(img, 0, 0, cvs.width, cvs.height);
                
                // Get Color (Simplified)
                const p = ctx.getImageData(0,0,1,1).data;
                const color = Utils.rgbToHsl(p[0],p[1],p[2]);

                cvs.toBlob(blob => {
                    const thumbUrl = URL.createObjectURL(blob);
                    URL.revokeObjectURL(url); // Clean original load url
                    const asset = {
                        id: Utils.uuid(),
                        file: file, // Store File Object for export
                        previewSrc: thumbUrl,
                        width: img.width, height: img.height,
                        aspectRatio: img.width / img.height,
                        hue: color.h
                    };
                    this.db.saveAsset(asset); // Persist
                    resolve(asset);
                }, 'image/jpeg', 0.7);
            };
            img.src = url;
        });
    }

    autoFlow() {
        this.pushHistory();
        // Collect all IDs from pages
        const allIds = this.pages.flat();
        if (allIds.length === 0) return;

        const limit = parseInt(this.settings.photosPerPage);
        const newPages = [];
        for (let i = 0; i < allIds.length; i += limit) {
            newPages.push(allIds.slice(i, i + limit));
        }
        this.pages = newPages;
        this.notify();
    }

    movePhoto(photoId, fromContext, toContext, targetIndex = -1) {
        this.pushHistory();
        
        // Remove from Source
        if (fromContext.type === 'depot') {
            this.depot = this.depot.filter(id => id !== photoId);
        } else {
            const p = this.pages[fromContext.index];
            this.pages[fromContext.index] = p.filter(id => id !== photoId);
        }

        // Add to Dest
        if (toContext.type === 'depot') {
            this.depot.push(photoId);
        } else {
            const destPage = this.pages[toContext.index];
            if (targetIndex > -1) destPage.splice(targetIndex, 0, photoId);
            else destPage.push(photoId);
        }
        this.notify();
    }

    deletePhoto(id) {
        this.pushHistory();
        this.pages = this.pages.map(p => p.filter(pid => pid !== id));
        this.depot = this.depot.filter(pid => pid !== id);
        this.photos.delete(id);
        this.
