<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fotogrid Pro - Ny Side Dialog & Angre Fix</title>
  
  <link rel="icon" type="image/png" href="icon.png">
  <meta name="theme-color" content="#2563eb">

  <style>
    /* --- CSS STYLES --- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    .app-container { min-height: 100vh; background-color: #e5e7eb; display: flex; }
    
    .version-label {
      position: fixed; top: 10px; right: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      border: 1px solid #e5e7eb; color: #6b7280;
      padding: 4px 8px; border-radius: 6px;
      font-size: 11px; font-weight: 600;
      z-index: 100; pointer-events: none; font-family: monospace;
    }

    /* Sidebar */
    .sidebar { width: 340px; background-color: white; border-right: 1px solid #e5e7eb; display: flex; flex-direction: column; z-index: 30; flex-shrink: 0; height: 100vh; }
    .sidebar-header { padding: 24px 24px 16px 24px; border-bottom: 1px solid #e5e7eb; }
    .sidebar-header h1 { font-size: 24px; font-weight: 600; color: #111827; margin-bottom: 4px; }
    .sidebar-header p { font-size: 14px; color: #6b7280; }
    
    .sidebar-content { flex: 1; overflow-y: auto; padding: 24px; display: flex; flex-direction: column; gap: 24px; }
    .sidebar-footer { padding: 24px; border-top: 1px solid #e5e7eb; }
    
    /* Controls */
    .control-group { display: flex; flex-direction: column; gap: 8px; }
    .control-group label { font-size: 14px; font-weight: 500; color: #374151; }
    .photo-count { font-size: 12px; color: #6b7280; margin-top: 8px; }
    
    /* Buttons */
    .btn-primary { width: 100%; padding: 12px 16px; background-color: #2563eb; color: white; border: none; border-radius: 8px; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; }
    .btn-primary:hover { background-color: #1d4ed8; }
    .btn-secondary { width: 100%; padding: 8px 16px; background-color: white; color: #374151; border: 1px solid #d1d5db; border-radius: 8px; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s;}
    .btn-secondary:hover:not(:disabled) { border-color: #9ca3af; background-color: #f3f4f6; }
    .btn-secondary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-danger { width: 100%; padding: 8px 16px; color: #dc2626; background-color: white; border: 1px solid #fca5a5; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
    .btn-danger:hover { background-color: #fef2f2; }
    .btn-export { width: 100%; padding: 12px 16px; background-color: #111827; color: white; border: none; border-radius: 8px; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; }
    .btn-export:hover { background-color: #1f2937; }
    .btn-export:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .button-group { display: flex; gap: 8px; }
    .button-group button { flex: 1; padding: 8px 16px; background-color: white; color: #374151; border: 1px solid #d1d5db; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
    .button-group button:hover { border-color: #9ca3af; }
    .button-group button.active { background-color: #eff6ff; border-color: #2563eb; color: #1d4ed8; }
    
    /* Inputs */
    select, input[type="text"] { width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 8px; font-size: 14px; outline: none; transition: border-color 0.2s; }
    select:focus, input[type="text"]:focus { border-color: #2563eb; box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1); }
    input[type="range"] { width: 100%; }
    input[type="number"] { -moz-appearance: textfield; }
    input[type="number"]::-webkit-outer-spin-button, input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .color-input-group { display: flex; gap: 8px; }
    .color-input-group input[type="color"] { width: 48px; height: 40px; border: 1px solid #d1d5db; border-radius: 8px; cursor: pointer; }
    .color-input-group input[type="text"] { flex: 1; font-family: 'Courier New', monospace; }
    
    /* Main Canvas */
    .main-canvas { flex: 1; padding: 0; display: flex; flex-direction: column; align-items: center; height: 100vh; position: relative; overflow: hidden; }
    .canvas-wrapper { 
      display: flex; flex-direction: row; align-items: center; justify-content: flex-start;
      width: 100%; height: 100%; overflow-x: auto; overflow-y: hidden;
      padding: 0 40px; gap: 60px; scroll-behavior: smooth;
    }
    
    /* Page Container */
    .page-container {
        display: flex; flex-direction: column; align-items: center; flex-shrink: 0;
        opacity: 0.4; transition: all 0.3s ease; transform: scale(0.9);
    }
    .page-container.active { opacity: 1; transform: scale(1); z-index: 10; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); }
    .page-container:hover { opacity: 0.9; transform: scale(0.95); }
    .page-container.active:hover { transform: scale(1); opacity: 1; }

    .page-header {
      display: flex; align-items: center; justify-content: space-between; width: 100%;
      margin-bottom: 12px; 
    }
    .page-label-group {
      display: flex; align-items: center; gap: 8px;
      background: white; padding: 4px 8px; border-radius: 12px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .page-label { font-size: 14px; font-weight: 600; color: #4b5563; user-select: none; }
    
    .delete-page-btn {
      background: #fee2e2; color: #ef4444; border: 1px solid #fecaca;
      border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center;
      cursor: pointer; opacity: 0; transition: opacity 0.2s;
    }
    .page-container:hover .delete-page-btn { opacity: 1; }
    .delete-page-btn:hover { background: #ef4444; color: white; border-color: #ef4444; }

    .canvas { 
      position: relative; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); flex-shrink: 0; 
      border: 1px solid #d1d5db; overflow: hidden; background-color: white;
      transition: width 0.3s, height 0.3s;
    }
    
    .photo-cell { position: absolute; overflow: hidden; background-color: #f3f4f6; transition: all 0.2s ease; cursor: grab; }
    .photo-cell:active { cursor: grabbing; }
    .photo-cell img { width: 100%; height: 100%; object-fit: cover; object-position: center; pointer-events: none; }
    .photo-cell:hover .remove-btn { opacity: 1; }
    .remove-btn { position: absolute; top: 4px; right: 4px; padding: 4px; background-color: #ef4444; color: white; border: none; border-radius: 50%; cursor: pointer; opacity: 0; transition: all 0.15s; z-index: 5; }
    .remove-btn:hover { background-color: #dc2626; }

    /* Modals */
    .modal-overlay { position: fixed; inset: 0; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 200; }
    .modal-overlay.open { display: flex; }
    .modal-box { background: white; width: 300px; padding: 24px; border-radius: 12px; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 16px; }
    .modal-title { font-size: 18px; font-weight: 600; }
    .modal-inputs { display: flex; gap: 12px; }
    .modal-input-grp { flex: 1; }
    .modal-input-grp label { display: block; font-size: 12px; font-weight: 500; margin-bottom: 4px; color: #4b5563; }
    .modal-input-grp input, .modal-input-grp select { width: 100%; }
    .modal-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px; }

    @media (max-width: 900px) {
      .app-container { flex-direction: column; }
      .sidebar { width: 100%; border-right: none; border-bottom: 1px solid #e5e7eb; height: auto; max-height: 40vh; }
      .main-canvas { height: 60vh; }
      .canvas-wrapper { padding: 20px 16px; gap: 16px; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
  
  <div class="version-label">V072 - New Page Dialog</div>

  <div id="customSizeModal" class="modal-overlay">
    <div class="modal-box">
      <h3 class="modal-title">Egendefinert størrelse</h3>
      <div class="modal-inputs">
        <div class="modal-input-grp"><label>Bredde (mm)</label><input type="number" id="customWidth" value="210"></div>
        <div class="modal-input-grp"><label>Høyde (mm)</label><input type="number" id="customHeight" value="297"></div>
      </div>
      <div class="modal-actions">
        <button class="btn-secondary" onclick="document.getElementById('customSizeModal').classList.remove('open')">Avbryt</button>
        <button class="btn-primary" onclick="applyCustomSize()">Bruk</button>
      </div>
    </div>
  </div>

  <div id="addPageModal" class="modal-overlay">
    <div class="modal-box">
      <h3 class="modal-title">Legg til ny side</h3>
      <div class="modal-inputs">
        <div class="modal-input-grp">
          <label>Hvor vil du sette inn siden?</label>
          <select id="pageInsertSelect">
            </select>
        </div>
      </div>
      <div class="modal-actions">
        <button class="btn-secondary" onclick="document.getElementById('addPageModal').classList.remove('open')">Avbryt</button>
        <button class="btn-primary" onclick="confirmAddPage()">Legg til</button>
      </div>
    </div>
  </div>

  <div class="app-container">
    <div class="sidebar">
      <div class="sidebar-header">
        <h1>Fotogrid</h1>
        <p>Print-klare layouter</p>
      </div>

      <div class="sidebar-content">
        <div class="control-group">
          <label>Bilder</label>
          <div style="display:flex; flex-wrap: wrap; gap:8px;">
            <button class="btn-primary" onclick="document.getElementById('fileInput').click()" style="flex:2;">
                Legg til
            </button>
            <button class="btn-secondary" id="undoBtn" onclick="undo()" disabled title="Angre" style="flex:1">
                Angre
            </button>
          </div>
          <input type="file" id="fileInput" accept="image/*" multiple style="display: none" onchange="handleFiles(this.files)">
          <p class="photo-count"><span id="photoCount">0</span> bilder</p>
        </div>
        
        <div class="control-group">
            <label>Sider</label>
            <div style="display: flex; gap: 8px;">
                <button class="btn-secondary" onclick="openAddPageModal()" style="flex:1">
                    Ny side
                </button>
                <button class="btn-secondary" onclick="autoFlow()" title="Tilbakestill layout" style="flex:1">
                    Autoflyt
                </button>
            </div>
        </div>

        <div class="control-group">
          <label>Bilder per side</label>
          <div style="display: flex; gap: 8px; align-items: center;">
            <input type="range" id="photosPerPage" min="1" max="36" value="4" oninput="updateSetting('photosPerPage', this.value)">
            <input type="number" id="photosPerPageInput" min="1" max="36" value="4" oninput="updateSetting('photosPerPage', this.value)" style="width: 60px;">
          </div>
        </div>

        <div class="control-group">
          <label>Papirstørrelse</label>
          <select id="paperSize" onchange="setPaperSize(this.value)">
            <option value="A4" selected>A4 (210×297mm)</option>
            <option value="A3">A3 (297×420mm)</option>
            <option value="PHOTO_10X15">10×15 cm</option>
            <option value="CUSTOM">Spesial...</option>
          </select>
        </div>

        <div class="control-group">
          <label>Retning</label>
          <div class="button-group">
            <button id="portraitBtn" class="active" onclick="setOrientation('portrait')">Portrett</button>
            <button id="landscapeBtn" onclick="setOrientation('landscape')">Landskap</button>
          </div>
        </div>

        <div class="control-group">
          <label>Marg: <span id="marginValue">2</span>mm</label>
          <input type="range" id="margin" min="0" max="50" step="0.5" value="2" oninput="updateSetting('margin', this.value)">
        </div>

        <div class="control-group">
          <label>Avstand: <span id="gapValue">2</span>mm</label>
          <input type="range" id="gap" min="0" max="20" step="0.5" value="2" oninput="updateSetting('gap', this.value)">
        </div>

        <div class="control-group">
          <label>Bakgrunn</label>
          <div class="color-input-group">
            <input type="color" id="bgColorPicker" value="#FFFFFF" oninput="updateSetting('bgColor', this.value)">
            <input type="text" id="bgColorText" value="#FFFFFF" oninput="updateSetting('bgColor', this.value)">
          </div>
        </div>

        <div class="control-group">
            <label>Eksport DPI</label>
            <select id="dpi">
              <option value="150">150 DPI (Rask)</option>
              <option value="300" selected>300 DPI (Print)</option>
            </select>
        </div>
      </div>

      <div class="sidebar-footer">
        <button id="exportBtn" class="btn-export" onclick="exportGrid()">
           Last ned ZIP
        </button>
      </div>
    </div>

    <div class="main-canvas">
      <div class="canvas-wrapper" id="canvasWrapper">
        </div>
    </div>
  </div>

<script>
/**
 * FOTOGRID LOGIKK - REVIDERT VERSJON
 * Inkluderer: Deep Undo, New Page Dialog, IndexedDB
 */

// --- STATE ---
let pages = []; // Array av Arrays med bilde-objekter: [[img1, img2], [img3]]
let historyStack = [];
const MAX_HISTORY = 50;

let settings = {
    photosPerPage: 4,
    paperSize: 'A4',
    customWidth: 210,
    customHeight: 297,
    orientation: 'portrait',
    margin: 2,
    gap: 2,
    bgColor: '#FFFFFF'
};

const PAPER_SIZES = {
    'A4': { w: 210, h: 297 },
    'A3': { w: 297, h: 420 },
    'PHOTO_10X15': { w: 100, h: 150 }
};

// --- DB SETUP (For å lagre store bilder) ---
let db;
async function initDB() {
    return new Promise((resolve, reject) => {
        const req = indexedDB.open('FotoGridDB', 1);
        req.onupgradeneeded = (e) => {
            db = e.target.result;
            if (!db.objectStoreNames.contains('images')) {
                db.createObjectStore('images', { keyPath: 'id' });
            }
        };
        req.onsuccess = (e) => {
            db = e.target.result;
            resolve(db);
        };
        req.onerror = (e) => reject(e);
    });
}

async function storeImage(file) {
    const id = Date.now() + Math.random().toString();
    const blob = file; 
    return new Promise((resolve, reject) => {
        const tx = db.transaction('images', 'readwrite');
        const store = tx.objectStore('images');
        store.put({ id, blob });
        tx.oncomplete = () => resolve(id);
        tx.onerror = () => reject(tx.error);
    });
}

async function getImageBlob(id) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction('images', 'readonly');
        const store = tx.objectStore('images');
        const req = store.get(id);
        req.onsuccess = () => resolve(req.result ? req.result.blob : null);
        req.onerror = () => reject(req.error);
    });
}

// --- UNDO SYSTEM ---
function saveState() {
    const state = JSON.stringify(pages);
    historyStack.push(state);
    if (historyStack.length > MAX_HISTORY) historyStack.shift();
    updateUndoButton();
}

function undo() {
    if (historyStack.length === 0) return;
    const previousState = historyStack.pop();
    pages = JSON.parse(previousState);
    updateUndoButton();
    updateUI();
}

function updateUndoButton() {
    const btn = document.getElementById('undoBtn');
    btn.disabled = historyStack.length === 0;
    btn.style.opacity = historyStack.length === 0 ? "0.5" : "1";
}

// --- ACTIONS ---

// Åpne dialogboks for ny side
function openAddPageModal() {
    const modal = document.getElementById('addPageModal');
    const select = document.getElementById('pageInsertSelect');
    select.innerHTML = '';

    pages.forEach((_, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.text = `Før side ${i + 1}`;
        select.appendChild(opt);
    });

    const lastOpt = document.createElement('option');
    lastOpt.value = pages.length;
    lastOpt.text = `Til slutt (Side ${pages.length + 1})`;
    lastOpt.selected = true;
    select.appendChild(lastOpt);

    modal.classList.add('open');
}

function confirmAddPage() {
    saveState();
    const select = document.getElementById('pageInsertSelect');
    const index = parseInt(select.value);
    pages.splice(index, 0, []); // Sett inn tom side
    document.getElementById('addPageModal').classList.remove('open');
    updateUI();
    
    // Scroll til ny side
    setTimeout(() => {
        const els = document.querySelectorAll('.page-container');
        if(els[index]) els[index].scrollIntoView({behavior:'smooth', inline:'center'});
    }, 100);
}

// Legg til bilder
async function handleFiles(fileList) {
    if (!fileList.length) return;
    saveState();
    
    // Hvis vi ikke har sider, lag en
    if (pages.length === 0) pages.push([]);

    for (let file of fileList) {
        try {
            const id = await storeImage(file);
            // Finn første side med plass, eller legg til sist
            let added = false;
            for (let page of pages) {
                if (page.length < settings.photosPerPage) {
                    page.push({ id });
                    added = true;
                    break;
                }
            }
            if (!added) {
                // Legg til på siste side selv om den er full, eller lag ny? 
                // Logikk: Fyll siste side hvis mulig, ellers lag ny.
                // Her: Fyller siste side for enkelhets skyld, AutoFlow kan fikse senere
                pages[pages.length-1].push({ id });
            }
        } catch (e) {
            console.error("Feil ved lagring av bilde", e);
        }
    }
    updateUI();
}

function autoFlow() {
    saveState();
    // Samle alle bilder
    let allPhotos = [];
    pages.forEach(p => allPhotos = allPhotos.concat(p));
    
    // Fordel på nytt basert på settings.photosPerPage
    pages = [];
    while(allPhotos.length > 0) {
        pages.push(allPhotos.splice(0, settings.photosPerPage));
    }
    if (pages.length === 0) pages.push([]);
    updateUI();
}

function deletePage(index) {
    saveState();
    // Flytt bilder til "Unsorted" eller bare slett? 
    // Vanligvis sletter man bildene også i en grid-app, eller flytter dem til forrige side.
    // Her sletter vi siden og innholdet for enkelhets skyld, siden vi har Angre-knapp.
    pages.splice(index, 1);
    if(pages.length === 0) pages.push([]);
    updateUI();
}

function deletePhoto(pageIndex, photoIndex) {
    saveState();
    pages[pageIndex].splice(photoIndex, 1);
    updateUI();
}

// --- SETTINGS ---
function updateSetting(key, value) {
    if (key === 'photosPerPage' || key === 'margin' || key === 'gap') value = parseFloat(value);
    
    // Oppdater UI verdier
    if(key === 'photosPerPage') {
        document.getElementById('photosPerPage').value = value;
        document.getElementById('photosPerPageInput').value = value;
    }
    if(key === 'margin') document.getElementById('marginValue').innerText = value;
    if(key === 'gap') document.getElementById('gapValue').innerText = value;
    if(key === 'bgColor') {
        document.getElementById('bgColorPicker').value = value;
        document.getElementById('bgColorText').value = value;
    }

    settings[key] = value;
    
    // Hvis antall per side endres, kjør autoflow? 
    // Mange brukere foretrekker at bildene blir stående, men rutenettet endres.
    updateUI();
}

function setPaperSize(val) {
    if (val === 'CUSTOM') {
        document.getElementById('customSizeModal').classList.add('open');
    } else {
        settings.paperSize = val;
        updateUI();
    }
}

function applyCustomSize() {
    settings.customWidth = parseFloat(document.getElementById('customWidth').value);
    settings.customHeight = parseFloat(document.getElementById('customHeight').value);
    settings.paperSize = 'CUSTOM';
    document.getElementById('customSizeModal').classList.remove('open');
    updateUI();
}

function setOrientation(ori) {
    settings.orientation = ori;
    document.getElementById('portraitBtn').className = ori === 'portrait' ? 'active' : '';
    document.getElementById('landscapeBtn').className = ori === 'landscape' ? 'active' : '';
    updateUI();
}

// --- RENDERING ---
function getPageDims() {
    let w, h;
    if (settings.paperSize === 'CUSTOM') {
        w = settings.customWidth; h = settings.customHeight;
    } else {
        const s = PAPER_SIZES[settings.paperSize] || PAPER_SIZES['A4'];
        w = s.w; h = s.h;
    }
    if (settings.orientation === 'landscape') return [Math.max(w,h), Math.min(w,h)];
    return [Math.min(w,h), Math.max(w,h)];
}

function updateUI() {
    const wrapper = document.getElementById('canvasWrapper');
    wrapper.innerHTML = '';
    
    // Oppdater teller
    let count = 0;
    pages.forEach(p => count += p.length);
    document.getElementById('photoCount').innerText = count;

    const [pageW, pageH] = getPageDims();
    // Skaler ned for visning (konverter mm til px grovt, men hold ratio)
    const displayScale = 1.5; // Pixels per mm for skjermvisning
    const cssW = pageW * displayScale;
    const cssH = pageH * displayScale;

    pages.forEach((page, pIndex) => {
        const pageEl = document.createElement('div');
        pageEl.className = 'page-container';
        pageEl.innerHTML = `
            <div class="page-header">
                <div class="page-label-group">
                    <span class="page-label">Side ${pIndex + 1}</span>
                </div>
                <button class="delete-page-btn" onclick="deletePage(${pIndex})" title="Slett side">×</button>
            </div>
            <div class="canvas" style="width:${cssW}px; height:${cssH}px; background:${settings.bgColor};" 
                 ondrop="handleDrop(event, ${pIndex})" ondragover="allowDrop(event)">
                </div>
        `;

        const canvas = pageEl.querySelector('.canvas');
        renderGrid(canvas, page, cssW, cssH, pIndex);
        wrapper.appendChild(pageEl);
    });
}

function renderGrid(container, photos, w, h, pIndex) {
    if (!photos.length) return;

    // Enkel rutenett-kalkulator
    const cols = Math.ceil(Math.sqrt(photos.length));
    const rows = Math.ceil(photos.length / cols);
    
    const cellW = (w - (settings.margin*2*1.5) - (settings.gap*(cols-1)*1.5)) / cols;
    const cellH = (h - (settings.margin*2*1.5) - (settings.gap*(rows-1)*1.5)) / rows;
    
    photos.forEach((photo, i) => {
        const r = Math.floor(i / cols);
        const c = i % cols;
        
        const x = (settings.margin*1.5) + c * (cellW + settings.gap*1.5);
        const y = (settings.margin*1.5) + r * (cellH + settings.gap*1.5);

        const cell = document.createElement('div');
        cell.className = 'photo-cell';
        cell.style.left = `${x}px`;
        cell.style.top = `${y}px`;
        cell.style.width = `${cellW}px`;
        cell.style.height = `${cellH}px`;
        
        // Hent bildet asynkront
        const img = document.createElement('img');
        getImageBlob(photo.id).then(blob => {
            if(blob) img.src = URL.createObjectURL(blob);
        });
        
        cell.innerHTML = `<button class="remove-btn" onclick="deletePhoto(${pIndex}, ${i})">×</button>`;
        cell.appendChild(img);
        container.appendChild(cell);
    });
}

// --- DRAG AND DROP ---
function allowDrop(ev) { ev.preventDefault(); }
function handleDrop(ev, pageIndex) {
    ev.preventDefault();
    // Her kan man implementere flytting mellom sider hvis man vil
    // For nå støtter vi fil-drop rett på siden
    if (ev.dataTransfer.files && ev.dataTransfer.files.length > 0) {
        handleFiles(ev.dataTransfer.files);
    }
}

// --- EXPORT ---
async function exportGrid() {
    const btn = document.getElementById('exportBtn');
    btn.textContent = "Genererer...";
    btn.disabled = true;

    try {
        const zip = new JSZip();
        const dpi = parseInt(document.getElementById('dpi').value);
        const scale = dpi / 25.4; // px per mm
        const [mmW, mmH] = getPageDims();
        const pxW = mmW * scale;
        const pxH = mmH * scale;

        for (let i = 0; i < pages.length; i++) {
            if (pages[i].length === 0) continue;
            
            // Tegn til canvas for eksport
            const canvas = document.createElement('canvas');
            canvas.width = pxW;
            canvas.height = pxH;
            const ctx = canvas.getContext('2d');
            
            // Bakgrunn
            ctx.fillStyle = settings.bgColor;
            ctx.fillRect(0,0, pxW, pxH);

            // Grid logikk (samme som renderGrid men med canvas ctx)
            const photos = pages[i];
            const cols = Math.ceil(Math.sqrt(photos.length));
            const rows = Math.ceil(photos.length / cols);
            const m = settings.margin * scale;
            const g = settings.gap * scale;
            const cellW = (pxW - (m*2) - (g*(cols-1))) / cols;
            const cellH = (pxH - (m*2) - (g*(rows-1))) / rows;

            for (let j=0; j<photos.length; j++) {
                const blob = await getImageBlob(photos[j].id);
                if (!blob) continue;
                const imgBitmap = await createImageBitmap(blob);
                
                const r = Math.floor(j / cols);
                const c = j % cols;
                const x = m + c * (cellW + g);
                const y = m + r * (cellH + g);
                
                // Tegn bilde (crop/fit center)
                // Enkel draw for nå: strekk til boks (object-fit:cover er mer complex i canvas)
                // Vi lager en enkel "cover" simulering:
                const ratio = imgBitmap.width / imgBitmap.height;
                const boxRatio = cellW / cellH;
                let dw = cellW, dh = cellH, dx = x, dy = y;
                let sx=0, sy=0, sw=imgBitmap.width, sh=imgBitmap.height;

                if (ratio > boxRatio) { // Bildet er bredere enn boksen
                     sw = sh * boxRatio;
                     sx = (imgBitmap.width - sw) / 2;
                } else { // Bildet er høyere
                     sh = sw / boxRatio;
                     sy = (imgBitmap.height - sh) / 2;
                }
                ctx.drawImage(imgBitmap, sx, sy, sw, sh, x, y, cellW, cellH);
            }
            
            const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.9));
            zip.file(`side-${i+1}.jpg`, blob);
        }

        const zipContent = await zip.generateAsync({type:"blob"});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(zipContent);
        a.download = "fotogrid-export.zip";
        a.click();
    } catch (err) {
        alert("Feil ved eksport: " + err);
    } finally {
        btn.textContent = "Last ned ZIP";
        btn.disabled = false;
    }
}

// Start
initDB().then(() => {
    pages = [[]]; // Start med en tom side
    updateUI();
});

</script>
</body>
</html>
