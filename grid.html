<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fotogrid Pro V1.0 - Arkitekt</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <style>
        :root {
            /* Farger og Tema */
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-app: #e5e7eb;
            --bg-panel: #ffffff;
            --text-main: #111827;
            --text-muted: #6b7280;
            --border: #d1d5db;
            --danger: #ef4444;
            
            /* Dimensjoner */
            --sidebar-width: 340px;
            --depot-height: 140px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; height: 100vh; overflow: hidden; background: var(--bg-app); color: var(--text-main); }
        
        /* Layout Grid */
        .app-shell {
            display: grid;
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-rows: 1fr var(--depot-height);
            height: 100vh;
            width: 100vw;
        }

        /* Sidebar */
        .sidebar {
            grid-row: 1 / -1;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            z-index: 20;
        }
        .sidebar-header { padding: 20px; border-bottom: 1px solid var(--border); }
        .sidebar-header h1 { font-size: 20px; font-weight: 700; color: var(--text-main); }
        .sidebar-content { padding: 20px; display: flex; flex-direction: column; gap: 18px; }

        /* Main Canvas Area */
        .main-area {
            grid-column: 2;
            grid-row: 1;
            background: var(--bg-app);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .canvas-scroller {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            align-items: center;
            padding: 40px;
            gap: 20px;
        }

        /* Depot Area */
        .depot-area {
            grid-column: 2;
            grid-row: 2;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 30;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.05);
        }
        .depot-header {
            padding: 8px 20px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-muted);
            background: #f9fafb;
            border-bottom: 1px solid #f3f4f6;
            display: flex; justify-content: space-between;
        }
        .depot-content {
            flex: 1;
            overflow-x: auto;
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .depot-content.drag-over { background-color: #eff6ff; }

        /* UI Components */
        .control-group { display: flex; flex-direction: column; gap: 6px; }
        .control-label { font-size: 13px; font-weight: 600; color: var(--text-main); display: flex; justify-content: space-between; }
        
        .btn { border: none; padding: 10px; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; transition: all 0.2s; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-secondary { background: white; border: 1px solid var(--border); color: var(--text-main); }
        .btn-secondary:hover { background: #f9fafb; border-color: #9ca3af; }
        .btn-secondary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-icon { width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; padding: 0; }

        input[type="text"], input[type="number"], select {
            width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px;
        }

        /* Page & Grid */
        .page-container {
            display: flex; flex-direction: column; align-items: center;
            flex-shrink: 0; transition: transform 0.2s;
            position: relative;
        }
        .page-container.active { transform: scale(1.02); z-index: 10; }
        
        .page-header { width: 100%; display: flex; justify-content: space-between; margin-bottom: 5px; align-items: center; }
        .page-badge { background: white; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: bold; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        
        .canvas {
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            transition: border 0.2s, box-shadow 0.2s;
        }
        .canvas.drop-target { border: 4px solid var(--primary); }

        .photo-cell {
            position: absolute;
            background: #e5e7eb;
            overflow: hidden;
            cursor: grab;
            transition: opacity 0.2s;
        }
        .photo-cell img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .photo-cell.dragging { opacity: 0.4; }
        
        /* Remove Button Overlay */
        .remove-btn {
            position: absolute; top: 4px; right: 4px;
            width: 20px; height: 20px;
            background: rgba(239, 68, 68, 0.9); color: white;
            border-radius: 50%; border: none; cursor: pointer;
            opacity: 0; transition: opacity 0.2s;
            display: flex; align-items: center; justify-content: center; font-size: 12px;
        }
        .photo-cell:hover .remove-btn, .depot-item:hover .remove-btn { opacity: 1; }

        /* Depot Items */
        .depot-item {
            width: 80px; height: 80px; flex-shrink: 0;
            border-radius: 6px; overflow: hidden;
            border: 1px solid var(--border);
            position: relative; cursor: grab; background: white;
        }
        .depot-item img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }

        /* Helpers */
        .hidden { display: none !important; }
        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
        .modal.open { opacity: 1; pointer-events: auto; }
        .modal-box { background: white; padding: 24px; border-radius: 8px; width: 320px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }

        /* Mobile Responsive */
        @media (max-width: 900px) {
            .app-shell { grid-template-columns: 1fr; grid-template-rows: 1fr 120px; }
            .sidebar { display: none; position: absolute; inset: 0; z-index: 50; }
            .sidebar.mobile-open { display: flex; }
        }
    </style>
</head>
<body>

<div class="app-shell">
    
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h1>Fotogrid Pro <span style="font-size: 0.6em; color: var(--primary);">V1.0</span></h1>
        </div>
        <div class="sidebar-content">
            
            <div class="control-group">
                <button class="btn btn-primary" id="uploadBtn">+ Last opp bilder</button>
                <input type="file" id="fileInput" multiple accept="image/*" class="hidden">
            </div>

            <div class="control-group">
                <label class="control-label">Prosjektnavn</label>
                <input type="text" id="projectName" placeholder="Mitt Prosjekt">
            </div>

            <div class="control-group">
                <label class="control-label">Papirstørrelse</label>
                <select id="paperSize">
                    <option value="A4">A4</option>
                    <option value="A3">A3</option>
                    <option value="PHOTO_10X15">10x15 Foto</option>
                    <option value="INSTASTORY">Instagram Story</option>
                    <option value="CUSTOM">Spesial...</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">Orientering</label>
                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-secondary" style="flex:1" id="orientPortrait">Stående</button>
                    <button class="btn btn-secondary" style="flex:1" id="orientLandscape">Liggende</button>
                </div>
            </div>

            <hr style="border: 0; border-top: 1px solid var(--border);">

            <div class="control-group">
                <label class="control-label">Bilder pr side <span id="valPhotosPerPage">10</span></label>
                <input type="range" id="photosPerPage" min="1" max="50" value="10">
            </div>

            <div class="control-group">
                <label class="control-label">Margin (mm) <span id="valMargin">5</span></label>
                <input type="range" id="margin" min="0" max="50" value="5">
            </div>

            <div class="control-group">
                <label class="control-label">Mellomrom (mm) <span id="valGap">2</span></label>
                <input type="range" id="gap" min="0" max="20" value="2">
            </div>
            
            <div class="control-group">
                <label class="control-label">Bakgrunnsfarge</label>
                <div style="display:flex; gap: 5px;">
                    <input type="color" id="bgColorPicker" value="#FFFFFF" style="height: 36px; width: 40px; padding: 0;">
                    <input type="text" id="bgColorText" value="#FFFFFF">
                </div>
            </div>

            <div style="margin-top: auto; display: flex; flex-direction: column; gap: 10px;">
                <button class="btn btn-secondary" id="autoFlowBtn">Autoflow (Nullstill sider)</button>
                <div style="display: flex; gap: 8px;">
                     <button class="btn btn-secondary" style="flex:1" id="undoBtn" disabled>Angre</button>
                     <button class="btn btn-secondary" style="flex:1" id="exportBtn">Last ned JPG</button>
                </div>
                <button class="btn btn-secondary" style="color: var(--danger); border-color: #fecaca;" id="resetAllBtn">Slett alt</button>
            </div>
        </div>
    </aside>

    <main class="main-area">
        <div id="saveStatus" style="position: absolute; top: 20px; right: 20px; background: white; padding: 5px 12px; border-radius: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); font-size: 12px; font-weight: bold; transform: translateY(-50px); transition: transform 0.3s;">Lagret</div>
        
        <div class="canvas-scroller" id="canvasWrapper">
            </div>

        <button id="toggleSidebarBtn" style="position:absolute; top:20px; left:20px; z-index:100; padding:10px; background:white; border:1px solid #ddd; border-radius:6px; display:none;">Meny</button>
    </main>

    <section class="depot-area">
        <div class="depot-header">
            <span>Bilde-depot</span>
            <span id="depotCount">0 bilder</span>
        </div>
        <div class="depot-content" id="depotContainer">
            </div>
    </section>

</div>

<div id="customSizeModal" class="modal">
    <div class="modal-box">
        <h3 style="margin-bottom: 15px;">Tilpasset Størrelse</h3>
        <div class="control-group">
            <label>Bredde (mm)</label>
            <input type="number" id="customWidth" value="200">
        </div>
        <div class="control-group" style="margin-top:10px;">
            <label>Høyde (mm)</label>
            <input type="number" id="customHeight" value="200">
        </div>
        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top: 20px;">
            <button class="btn btn-secondary" id="closeModalBtn">Avbryt</button>
            <button class="btn btn-primary" id="applyCustomBtn">Bruk</button>
        </div>
    </div>
</div>

<script>
/**
 * --- UTILITIES & CONFIG ---
 */
const CONFIG = {
    PAPER_SIZES: {
        A4: { width: 210, height: 297 },
        A3: { width: 297, height: 420 },
        PHOTO_10X15: { width: 100, height: 150 },
        INSTASTORY: { width: 108, height: 192 },
        CUSTOM: { width: 0, height: 0 }
    },
    DB_NAME: 'FotogridProDB_V1',
    DB_STORE: 'assets'
};

const Utils = {
    debounce: (func, wait) => {
        let timeout;
        return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func(...args), wait); };
    },
    uuid: () => Date.now().toString(36) + Math.random().toString(36).substr(2),
    rgbToHsl: (r, g, b) => {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) h = s = 0;
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h * 360, s, l };
    }
};

/**
 * --- STORAGE MANAGER (IndexedDB) ---
 */
class StorageManager {
    constructor() {
        this.db = null;
    }

    async init() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(CONFIG.DB_NAME, 1);
            req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(CONFIG.DB_STORE)) {
                    db.createObjectStore(CONFIG.DB_STORE, { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains('settings')) {
                    db.createObjectStore('settings', { keyPath: 'key' });
                }
            };
            req.onsuccess = (e) => { this.db = e.target.result; resolve(); };
            req.onerror = (e) => reject(e);
        });
    }

    async saveAsset(asset) {
        if (!this.db) return;
        this.db.transaction([CONFIG.DB_STORE], 'readwrite').objectStore(CONFIG.DB_STORE).put(asset);
    }

    async deleteAsset(id) {
        if (!this.db) return;
        this.db.transaction([CONFIG.DB_STORE], 'readwrite').objectStore(CONFIG.DB_STORE).delete(id);
    }

    async loadAssets() {
        if (!this.db) return [];
        return new Promise(resolve => {
            const tx = this.db.transaction([CONFIG.DB_STORE], 'readonly');
            const req = tx.objectStore(CONFIG.DB_STORE).getAll();
            req.onsuccess = () => resolve(req.result);
        });
    }

    async saveSettings(settings) {
        if (!this.db) return;
        // Vi lagrer kun en enkel JSON-dump av innstillingene
        const safeSettings = JSON.parse(JSON.stringify(settings));
        this.db.transaction(['settings'], 'readwrite').objectStore('settings').put({ key: 'main', val: safeSettings });
    }

    async loadSettings() {
        if (!this.db) return null;
        return new Promise(resolve => {
            const req = this.db.transaction(['settings'], 'readonly').objectStore('settings').get('main');
            req.onsuccess = () => resolve(req.result ? req.result.val : null);
        });
    }

    async clearAll() {
        if(!this.db) return;
        const tx = this.db.transaction([CONFIG.DB_STORE, 'settings'], 'readwrite');
        tx.objectStore(CONFIG.DB_STORE).clear();
        tx.objectStore('settings').clear();
        return new Promise(resolve => tx.oncomplete = resolve);
    }
}

/**
 * --- LAYOUT ENGINE (Pure Math) ---
 */
class LayoutEngine {
    static calculateGrid(photos, containerWidth, containerHeight, gap) {
        if (!photos || photos.length === 0) return { cells: [], height: 0 };
        
        let bestLayout = null;
        let bestScore = Infinity;

        // Prøv rader fra 1 til N for å finne best 'fit'
        for (let r = 1; r <= photos.length; r++) {
            const layout = this._createRows(photos, r, containerWidth, gap);
            const contentHeight = layout.naturalHeight;
            const targetHeight = containerHeight;
            
            // Beregn score basert på hvor godt det fyller høyden uten å skalere for mye
            const scale = targetHeight / contentHeight;
            let score;
            
            // Vi ønsker helst scale nær 1.0. 
            if (scale >= 0.85 && scale <= 1.15) score = Math.abs(1 - scale); 
            else if (scale < 0.85) score = 100 + (0.85 - scale); // Straff for mye tomrom
            else score = 100 + (scale - 1.15); // Straff for å måtte krympe for mye
            
            if (score < bestScore) {
                bestScore = score;
                bestLayout = { ...layout, scale };
            }
        }

        // Apply Layout
        let fitScale = bestLayout.scale;
        // Clamp scale to avoid extreme stretching
        fitScale = Math.max(0.9, Math.min(fitScale, 1.1));
        
        // Sjekk om det går utfor høyden, hvis ja, krymp til å passe
        let finalHeight = bestLayout.naturalHeight * fitScale;
        if (finalHeight > containerHeight) {
            fitScale = fitScale * (containerHeight / finalHeight);
            finalHeight = containerHeight;
        }

        const cells = [];
        let currentY = (containerHeight - finalHeight) / 2; // Sentrer vertikalt
        const finalWidth = containerWidth * fitScale;
        const startX = (containerWidth - finalWidth) / 2; // Sentrer horisontalt

        bestLayout.rows.forEach(row => {
            const rowHeight = row.baseHeight * fitScale;
            let currentX = startX;
            
            // Juster bredde på raden for gap
            const rowWidth = finalWidth - ((row.items.length - 1) * gap * fitScale);
            
            row.items.forEach(photo => {
                const width = (photo.aspectRatio / row.aspectSum) * rowWidth;
                cells.push({
                    photoId: photo.id,
                    x: currentX,
                    y: currentY,
                    width: width,
                    height: rowHeight
                });
                currentX += width + (gap * fitScale);
            });
            currentY += rowHeight + (gap * fitScale);
        });

        return { cells, height: finalHeight };
    }

    static _createRows(photos, rowCount, width, gap) {
        const rows = [];
        const basePer = Math.floor(photos.length / rowCount);
        let extra = photos.length % rowCount;
        let idx = 0;

        for (let i = 0; i < rowCount; i++) {
            const count = basePer + (i < extra ? 1 : 0);
            const items = [];
            let aspectSum = 0;
            for (let j = 0; j < count; j++) {
                if (idx < photos.length) {
                    items.push(photos[idx]);
                    aspectSum += photos[idx].aspectRatio;
                    idx++;
                }
            }
            if (items.length > 0) {
                // Høyde = (Bredde - Gaps) / AspectSum
                const totalGap = (items.length - 1) * gap;
                const h = (width - totalGap) / aspectSum;
                rows.push({ items, baseHeight: h, aspectSum });
            }
        }
        
        const totalGapH = (rows.length - 1) * gap;
        const naturalHeight = rows.reduce((acc, r) => acc + r.baseHeight, 0) + totalGapH;
        return { rows, naturalHeight };
    }
}

/**
 * --- STATE MANAGER (The Brain) ---
 */
class StateManager {
    constructor(db) {
        this.db = db;
        this.photos = new Map(); // All loaded photo assets
        this.pages = [[]];       // Array of Arrays of Photo IDs
        this.depot = [];         // Array of Photo IDs
        
        this.settings = {
            projectName: '',
            paperSize: 'A4',
            customSize: { w: 200, h: 200 },
            orientation: 'portrait',
            photosPerPage: 10,
            margin: 5,
            gap: 2,
            bgColor: '#FFFFFF'
        };

        this.history = [];
        this.listeners = [];
        this.saveTimeout = null;
    }

    subscribe(callback) { this.listeners.push(callback); }
    notify() { this.listeners.forEach(cb => cb(this)); this.scheduleSave(); }

    scheduleSave() {
        clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(() => {
            this.db.saveSettings({
                pages: this.pages,
                depot: this.depot,
                settings: this.settings
            });
            const status = document.getElementById('saveStatus');
            status.style.transform = 'translateY(0)';
            setTimeout(() => status.style.transform = 'translateY(-50px)', 1500);
        }, 1000);
    }

    pushHistory() {
        const state = JSON.stringify({ pages: this.pages, depot: this.depot });
        if (this.history.length === 0 || this.history[this.history.length-1] !== state) {
            this.history.push(state);
            if (this.history.length > 20) this.history.shift();
        }
        this.updateUndoState();
    }

    undo() {
        if (this.history.length === 0) return;
        const state = JSON.parse(this.history.pop());
        this.pages = state.pages;
        this.depot = state.depot;
        this.notify();
        this.updateUndoState();
    }

    updateUndoState() {
        const btn = document.getElementById('undoBtn');
        btn.disabled = this.history.length === 0;
        btn.textContent = this.history.length > 0 ? `Angre (${this.history.length})` : 'Angre';
    }

    // --- Actions ---

    async addPhotos(fileList) {
        this.pushHistory();
        const promises = fileList.map(file => this._processFile(file));
        const newAssets = await Promise.all(promises);
        
        // Add to global map
        newAssets.forEach(a => this.photos.set(a.id, a));
        
        // Add to current page
        const currentPageIdx = 0; // Simplified for now, could be active page
        if (this.pages.length === 0) this.pages.push([]);
        
        // Distribute to pages or just first? Let's add to first available or create new if full
        // For simplicity: Add to current visible page or last page
        this.pages[this.pages.length - 1].push(...newAssets.map(a => a.id));
        
        this.autoFlow(); // Re-distribute to look good
    }

    async _processFile(file) {
        return new Promise((resolve) => {
            const img = new Image();
            const url = URL.createObjectURL(file);
            img.onload = () => {
                // Create Tiny Thumbnail
                const scale = Math.min(1, 400 / img.width);
                const cvs = document.createElement('canvas');
                cvs.width = img.width * scale; cvs.height = img.height * scale;
                const ctx = cvs.getContext('2d');
                ctx.drawImage(img, 0, 0, cvs.width, cvs.height);
                
                // Get Color (Simplified)
                const p = ctx.getImageData(0,0,1,1).data;
                const color = Utils.rgbToHsl(p[0],p[1],p[2]);

                cvs.toBlob(blob => {
                    const thumbUrl = URL.createObjectURL(blob);
                    URL.revokeObjectURL(url); // Clean original load url
                    const asset = {
                        id: Utils.uuid(),
                        file: file, // Store File Object for export
                        previewSrc: thumbUrl,
                        width: img.width, height: img.height,
                        aspectRatio: img.width / img.height,
                        hue: color.h
                    };
                    this.db.saveAsset(asset); // Persist
                    resolve(asset);
                }, 'image/jpeg', 0.7);
            };
            img.src = url;
        });
    }

    autoFlow() {
        this.pushHistory();
        // Collect all IDs from pages
        const allIds = this.pages.flat();
        if (allIds.length === 0) return;

        const limit = parseInt(this.settings.photosPerPage);
        const newPages = [];
        for (let i = 0; i < allIds.length; i += limit) {
            newPages.push(allIds.slice(i, i + limit));
        }
        this.pages = newPages;
        this.notify();
    }

    movePhoto(photoId, fromContext, toContext, targetIndex = -1) {
        this.pushHistory();
        
        // Remove from Source
        if (fromContext.type === 'depot') {
            this.depot = this.depot.filter(id => id !== photoId);
        } else {
            const p = this.pages[fromContext.index];
            this.pages[fromContext.index] = p.filter(id => id !== photoId);
        }

        // Add to Dest
        if (toContext.type === 'depot') {
            this.depot.push(photoId);
        } else {
            const destPage = this.pages[toContext.index];
            if (targetIndex > -1) destPage.splice(targetIndex, 0, photoId);
            else destPage.push(photoId);
        }
        this.notify();
    }

    deletePhoto(id) {
        this.pushHistory();
        this.pages = this.pages.map(p => p.filter(pid => pid !== id));
        this.depot = this.depot.filter(pid => pid !== id);
        this.photos.delete(id);
        this.db.deleteAsset(id);
        this.notify();
    }

    setSetting(key, value) {
        if (this.settings[key] !== value) {
            // No history push for slider drag spam, handled by debounce in UI
            this.settings[key] = value;
            this.notify();
        }
    }

    getDimensions() {
        let size = CONFIG.PAPER_SIZES[this.settings.paperSize];
        if (this.settings.paperSize === 'CUSTOM') size = { width: this.settings.customSize.w, height: this.settings.customSize.h };
        
        if (this.settings.orientation === 'landscape') {
            return { width: size.height, height: size.width };
        }
        return size;
    }

    async load() {
        const assets = await this.db.loadAssets();
        assets.forEach(a => {
            // Re-create Blob URLs
            a.previewSrc = URL.createObjectURL(new Blob([a.file], {type: a.file.type})); 
            // Note: In real production, we'd store thumbnail blob in DB separately to avoid reading heavy file
            // For now, re-reading file is acceptable for < 100 images
            this.photos.set(a.id, a);
        });

        const savedData = await this.db.loadSettings();
        if (savedData) {
            this.pages = savedData.pages || [[]];
            this.depot = savedData.depot || [];
            Object.assign(this.settings, savedData.settings);
        }
        this.notify();
        this.updateUndoState();
    }

    async wipe() {
        this.pushHistory();
        this.pages = [[]];
        this.depot = [];
        this.photos.clear();
        await this.db.clearAll();
        this.notify();
    }
}

/**
 * --- RENDERER (DOM Manipulation) ---
 */
class Renderer {
    constructor(state) {
        this.state = state;
        this.elements = {
            wrapper: document.getElementById('canvasWrapper'),
            depot: document.getElementById('depotContainer'),
            depotCount: document.getElementById('depotCount')
        };
        // Bind UI inputs to State
        this.bindInputs();
    }

    bindInputs() {
        const s = this.state.settings;
        // Helper to bind input
        const bind = (id, key, type='value', event='change') => {
            const el = document.getElementById(id);
            if(!el) return;
            // Set initial
            if(key === 'customSize') return; // handled manually
            el[type] = s[key];
            
            // Listen
            el.addEventListener(event, (e) => {
                let val = e.target[type];
                if (e.target.type === 'number' || e.target.type === 'range') val = parseFloat(val);
                this.state.setSetting(key, val);
            });
        };

        bind('projectName', 'projectName');
        bind('paperSize', 'paperSize');
        bind('photosPerPage', 'photosPerPage', 'value', 'input');
        bind('margin', 'margin', 'value', 'input');
        bind('gap', 'gap', 'value', 'input');
        bind('bgColorText', 'bgColor');

        document.getElementById('bgColorPicker').addEventListener('input', (e) => {
            document.getElementById('bgColorText').value = e.target.value;
            this.state.setSetting('bgColor', e.target.value);
        });

        // Orientation Buttons
        const setOri = (o) => {
            document.getElementById('orientPortrait').classList.toggle('btn-primary', o === 'portrait');
            document.getElementById('orientPortrait').classList.toggle('btn-secondary', o !== 'portrait');
            document.getElementById('orientLandscape').classList.toggle('btn-primary', o === 'landscape');
            document.getElementById('orientLandscape').classList.toggle('btn-secondary', o !== 'landscape');
            this.state.setSetting('orientation', o);
        };
        document.getElementById('orientPortrait').onclick = () => setOri('portrait');
        document.getElementById('orientLandscape').onclick = () => setOri('landscape');
        setOri(s.orientation);

        // Display Values for Sliders
        const updateDisp = (id, val) => document.getElementById('val'+id).textContent = val;
        document.getElementById('photosPerPage').addEventListener('input', e => updateDisp('PhotosPerPage', e.target.value));
        document.getElementById('margin').addEventListener('input', e => updateDisp('Margin', e.target.value));
        document.getElementById('gap').addEventListener('input', e => updateDisp('Gap', e.target.value));
    }

    render() {
        requestAnimationFrame(() => {
            this.renderPages();
            this.renderDepot();
            this.updateLabels();
        });
    }

    updateLabels() {
        document.getElementById('valPhotosPerPage').textContent = this.state.settings.photosPerPage;
        document.getElementById('valMargin').textContent = this.state.settings.margin;
        document.getElementById('valGap').textContent = this.state.settings.gap;
        document.getElementById('bgColorPicker').value = this.state.settings.bgColor;
        document.getElementById('bgColorText').value = this.state.settings.bgColor;
    }

    renderPages() {
        const wrapper = this.elements.wrapper;
        const pages = this.state.pages;
        const dims = this.state.getDimensions();
        const settings = this.state.settings;

        // Calculate Display Scale (to fit in view)
        const padding = 60;
        const availHeight = wrapper.clientHeight - padding;
        const scale = Math.min(1, availHeight / dims.height);
        
        const dispW = dims.width * scale;
        const dispH = dims.height * scale;

        // Sync DOM Nodes (Simple Diffing)
        // Check current children count vs needed
        let domPages = Array.from(wrapper.getElementsByClassName('page-container'));
        
        // Remove excess
        while(domPages.length > pages.length) {
            domPages.pop().remove();
        }
        // Add missing
        while(domPages.length < pages.length) {
            const div = document.createElement('div');
            div.className = 'page-container';
            div.innerHTML = `
                <div class="page-header">
                    <span class="page-badge">Side ${domPages.length + 1}</span>
                </div>
                <div class="canvas"></div>
            `;
            wrapper.appendChild(div);
            domPages.push(div);
        }

        // Update Content
        pages.forEach((pagePhotoIds, i) => {
            const container = domPages[i];
            const canvas = container.querySelector('.canvas');
            
            // Update Canvas Style
            canvas.style.width = dispW + 'px';
            canvas.style.height = dispH + 'px';
            canvas.style.backgroundColor = settings.bgColor;
            
            container.dataset.pageIndex = i; // For Drag Drop

            // Calculate Grid
            const marginPx = (settings.margin / dims.width) * dispW;
            const gapPx = (settings.gap / dims.width) * dispW;
            const contentW = dispW - (2 * marginPx);
            const contentH = dispH - (2 * marginPx);

            // Get Asset Objects
            const assets = pagePhotoIds.map(id => this.state.photos.get(id)).filter(Boolean);

            const layout = LayoutEngine.calculateGrid(assets, contentW, contentH, gapPx);

            // Render Cells inside Canvas
            // Important: We clear canvas content every time here. 
            // For 10-50 photos, this is fast enough. A Virtual DOM would be overkill.
            canvas.innerHTML = ''; 
            
            // Grid Offset Container
            const gridDiv = document.createElement('div');
            gridDiv.style.position = 'absolute';
            gridDiv.style.left = marginPx + 'px';
            gridDiv.style.top = marginPx + 'px';
            gridDiv.style.width = contentW + 'px';
            gridDiv.style.height = contentH + 'px';
            
            layout.cells.forEach(cell => {
                const photo = this.state.photos.get(cell.photoId);
                const el = document.createElement('div');
                el.className = 'photo-cell';
                el.style.left = cell.x + 'px';
                el.style.top = cell.y + 'px';
                el.style.width = cell.width + 'px';
                el.style.height = cell.height + 'px';
                el.dataset.id = cell.photoId;
                el.draggable = true;

                el.innerHTML = `<img src="${photo.previewSrc}"><button class="remove-btn">×</button>`;
                
                // Event Delegation handled by DragManager
                el.querySelector('.remove-btn').onclick = (e) => {
                    e.stopPropagation();
                    if(confirm("Slette bildet?")) this.state.deletePhoto(cell.photoId);
                }

                gridDiv.appendChild(el);
            });
            canvas.appendChild(gridDiv);
        });
    }

    renderDepot() {
        const container = this.elements.depot;
        container.innerHTML = '';
        this.elements.depotCount.textContent = `${this.state.depot.length} bilder`;

        this.state.depot.forEach(id => {
            const photo = this.state.photos.get(id);
            if (!photo) return;

            const el = document.createElement('div');
            el.className = 'depot-item';
            el.dataset.id = id;
            el.draggable = true;
            el.innerHTML = `<img src="${photo.previewSrc}"><button class="remove-btn">×</button>`;
            
            el.querySelector('.remove-btn').onclick = (e) => {
                e.stopPropagation();
                this.state.deletePhoto(id);
            }
            container.appendChild(el);
        });
    }
}

/**
 * --- DRAG MANAGER ---
 */
class DragManager {
    constructor(state, renderer) {
        this.state = state;
        this.renderer = renderer;
        this.draggedId = null;
        this.sourceContext = null; // { type: 'page'|'depot', index: num }

        this.init();
    }

    init() {
        document.addEventListener('dragstart', this.onDragStart.bind(this));
        document.addEventListener('dragover', this.onDragOver.bind(this));
        document.addEventListener('drop', this.onDrop.bind(this));
        document.addEventListener('dragend', this.onDragEnd.bind(this));
    }

    onDragStart(e) {
        const cell = e.target.closest('.photo-cell, .depot-item');
        if (!cell) return;

        this.draggedId = cell.dataset.id;
        cell.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';

        // Identify Source
        const pageEl = cell.closest('.page-container');
        if (pageEl) {
            this.sourceContext = { type: 'page', index: parseInt(pageEl.dataset.pageIndex) };
        } else {
            this.sourceContext = { type: 'depot' };
        }
    }

    onDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        
        // Highlighting logic
        document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

        const pageCanvas = e.target.closest('.canvas');
        if (pageCanvas) {
            pageCanvas.classList.add('drop-target');
        }
        
        const depot = e.target.closest('.depot-content');
        if (depot) {
            depot.classList.add('drag-over');
        }
    }

    onDrop(e) {
        e.preventDefault();
        if (!this.draggedId) return;

        let targetContext = null;
        
        // Check Drop Target
        const pageContainer = e.target.closest('.page-container');
        const depotContainer = e.target.closest('.depot-content');

        if (pageContainer) {
            targetContext = { type: 'page', index: parseInt(pageContainer.dataset.pageIndex) };
        } else if (depotContainer) {
            targetContext = { type: 'depot' };
        }

        if (targetContext) {
            // Check if dropping on same place (optional optimization)
            if (this.sourceContext.type === targetContext.type && 
                this.sourceContext.index === targetContext.index) {
                // Moving inside same page? Not implemented yet (requires reorder logic)
                // For now, do nothing
            } else {
                this.state.movePhoto(this.draggedId, this.sourceContext, targetContext);
            }
        }
        
        this.cleanup();
    }

    onDragEnd() {
        this.cleanup();
    }

    cleanup() {
        this.draggedId = null;
        this.sourceContext = null;
        document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
        document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
    }
}

/**
 * --- APP INITIALIZATION ---
 */
const db = new StorageManager();
const state = new StateManager(db);
const renderer = new Renderer(state);
const dragManager = new DragManager(state, renderer);

// Hook up state changes to renderer
state.subscribe(() => renderer.render());

// --- GLOBAL EVENT LISTENERS ---

// 1. Upload
document.getElementById('uploadBtn').onclick = () => document.getElementById('fileInput').click();
document.getElementById('fileInput').onchange = (e) => {
    const files = Array.from(e.target.files);
    if(files.length) state.addPhotos(files);
    e.target.value = ''; // Reset
};

// 2. Toolbar Actions
document.getElementById('autoFlowBtn').onclick = () => { if(confirm("Dette vil omorganisere alle bilder. Fortsette?")) state.autoFlow(); };
document.getElementById('resetAllBtn').onclick = () => { if(confirm("Dette sletter ALT permanent. Er du sikker?")) state.wipe(); };
document.getElementById('undoBtn').onclick = () => state.undo();

// 3. Export Logic (Simplified)
document.getElementById('exportBtn').onclick = async () => {
    const btn = document.getElementById('exportBtn');
    btn.textContent = 'Genererer...';
    btn.disabled = true;

    try {
        const zip = new JSZip();
        const settings = state.settings;
        const dims = state.getDimensions();
        // 300 DPI conversion (mm -> px)
        const scale = 300 / 25.4; 
        const width = Math.round(dims.width * scale);
        const height = Math.round(dims.height * scale);
        
        const marginPx = Math.round(settings.margin * scale);
        const gapPx = Math.round(settings.gap * scale);

        for (let i = 0; i < state.pages.length; i++) {
            const pageIds = state.pages[i];
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // Fill Background
            ctx.fillStyle = settings.bgColor;
            ctx.fillRect(0,0, width, height);
            
            const assets = pageIds.map(id => state.photos.get(id)).filter(Boolean);
            const contentW = width - (2 * marginPx);
            const contentH = height - (2 * marginPx);
            
            const layout = LayoutEngine.calculateGrid(assets, contentW, contentH, gapPx);
            
            // Draw Images
            for (const cell of layout.cells) {
                const photo = state.photos.get(cell.photoId);
                const img = new Image();
                img.src = URL.createObjectURL(photo.file); // Load High Res
                await new Promise(r => img.onload = r);
                
                ctx.save();
                ctx.beginPath();
                ctx.rect(marginPx + cell.x, marginPx + cell.y, cell.width, cell.height);
                ctx.clip();
                
                // "Object-fit: cover" logic for canvas
                const sRatio = img.width / img.height;
                const dRatio = cell.width / cell.height;
                let sW, sH, sX, sY;
                
                if (sRatio > dRatio) {
                    sH = img.height; sW = sH * dRatio; sX = (img.width - sW) / 2; sY = 0;
                } else {
                    sW = img.width; sH = sW / dRatio; sX = 0; sY = (img.height - sH) / 2;
                }
                
                ctx.drawImage(img, sX, sY, sW, sH, marginPx + cell.x, marginPx + cell.y, cell.width, cell.height);
                ctx.restore();
            }

            const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.9));
            const name = (state.settings.projectName || 'Grid') + `_side${i+1}.jpg`;
            if (state.pages.length === 1) {
                // Direct download if single page
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = name;
                a.click();
            } else {
                zip.file(name, blob);
            }
        }

        if (state.pages.length > 1) {
            const zBlob = await zip.generateAsync({type: 'blob'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(zBlob);
            a.download = (state.settings.projectName || 'Grid') + '.zip';
            a.click();
        }

    } catch (e) {
        alert("Feil under eksport: " + e.message);
        console.error(e);
    } finally {
        btn.textContent = 'Last ned JPG';
        btn.disabled = false;
    }
};

// 4. Modal Logic (Custom Size)
const modal = document.getElementById('customSizeModal');
document.getElementById('paperSize').addEventListener('change', (e) => {
    if (e.target.value === 'CUSTOM') {
        modal.classList.add('open');
    }
});
document.getElementById('closeModalBtn').onclick = () => {
    modal.classList.remove('open');
    // Revert select to A4 or keep current? Simply force update UI back to stored val
    document.getElementById('paperSize').value = state.settings.paperSize === 'CUSTOM' ? 'CUSTOM' : state.settings.paperSize; 
};
document.getElementById('applyCustomBtn').onclick = () => {
    const w = parseFloat(document.getElementById('customWidth').value);
    const h = parseFloat(document.getElementById('customHeight').value);
    if(w > 0 && h > 0) {
        state.settings.customSize = { w, h };
        state.setSetting('paperSize', 'CUSTOM'); // Trigger update
        modal.classList.remove('open');
    }
};

// 5. Mobile Sidebar Toggle
const sb = document.getElementById('sidebar');
const toggleBtn = document.getElementById('toggleSidebarBtn');
// Simple detect mobile
if (window.innerWidth <= 900) toggleBtn.style.display = 'block';
toggleBtn.onclick = () => sb.classList.toggle('mobile-open');


// STARTUP
(async () => {
    try {
        await db.init();
        await state.load();
    } catch (e) {
        console.error("Critical Start Error", e);
        alert("Kunne ikke starte database. Prøv en annen nettleser.");
    }
})();

</script>
</body>
</html>
