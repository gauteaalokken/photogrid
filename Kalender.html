<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fotogrid Kalender 2026 - v2.1 (HEIC Support)</title>
  
  <style>
    /* --- CSS STYLES --- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background-color: #e5e7eb; height: 100vh; display: flex; overflow: hidden; }
    
    /* SIDEBAR */
    .sidebar { width: 320px; background: white; border-right: 1px solid #d1d5db; display: flex; flex-direction: column; z-index: 50; flex-shrink: 0; }
    .sidebar-header { padding: 20px; border-bottom: 1px solid #e5e7eb; }
    .sidebar-content { flex: 1; padding: 20px; display: flex; flex-direction: column; gap: 20px; overflow-y: auto; }
    .sidebar-footer { padding: 20px; border-top: 1px solid #e5e7eb; background: #f9fafb; }
    
    h1 { font-size: 20px; font-weight: 700; color: #111827; }
    .version-tag { display: inline-block; background: #e0f2fe; color: #0369a1; font-size: 11px; padding: 2px 6px; border-radius: 4px; font-weight: 600; margin-top: 4px; }
    p { font-size: 13px; color: #6b7280; }
    label { font-size: 13px; font-weight: 600; color: #374151; display: flex; justify-content: space-between; margin-bottom: 6px; }
    
    input[type="text"] { width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; }
    
    /* Range Sliders */
    input[type="range"] { width: 100%; cursor: pointer; }
    .slider-val { color: #2563eb; font-weight: 700; }
    
    .btn { width: 100%; padding: 10px; border-radius: 6px; font-weight: 500; cursor: pointer; border: none; display: flex; align-items: center; justify-content: center; gap: 8px; transition: 0.2s; font-size: 14px;}
    .btn-primary { background: #2563eb; color: white; }
    .btn-primary:hover { background: #1d4ed8; }
    .btn-secondary { background: white; border: 1px solid #d1d5db; color: #374151; }
    .btn-danger { background: #fee2e2; color: #dc2626; border: 1px solid #fecaca; }
    .btn:disabled { opacity: 0.6; cursor: wait; }

    /* MAIN AREA */
    .main-area { flex: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }

    /* INBOX */
    .inbox-container {
        height: 140px; background-color: #f3f4f6; border-bottom: 1px solid #d1d5db;
        display: flex; flex-direction: column; flex-shrink: 0; z-index: 40;
        box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
    }
    .inbox-header { padding: 8px 16px; font-size: 12px; font-weight: 600; color: #6b7280; text-transform: uppercase; letter-spacing: 0.05em; display:flex; justify-content: space-between; }
    .inbox-scroll {
        flex: 1; display: flex; align-items: center; gap: 12px; padding: 0 16px 12px 16px;
        overflow-x: auto; overflow-y: hidden; scroll-behavior: smooth;
    }
    .inbox-photo {
        height: 100px; min-width: 100px; border-radius: 6px; overflow: hidden; 
        border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.1); cursor: grab; position: relative;
        background: #e5e7eb; flex-shrink: 0;
    }
    .inbox-photo img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
    .inbox-photo:hover .remove-btn { opacity: 1; }

    /* CALENDAR SCROLL AREA */
    .calendar-scroll-area {
        flex: 1; overflow-y: auto; padding: 40px; display: flex; flex-direction: column; align-items: center; gap: 60px;
        scroll-behavior: smooth; background: #e5e7eb;
    }

    /* A4 PAGE (Preview scale) */
    .a4-page {
        width: 794px; height: 1123px; /* A4 @ 96 DPI */
        background: white; box-shadow: 0 10px 25px -5px rgba(0,0,0,0.15);
        display: flex; flex-direction: column; position: relative; flex-shrink: 0;
        transform-origin: top center;
    }
    
    /* TOP: PHOTO AREA */
    .photo-area {
        height: 60%; width: 100%; background-color: #f9fafb; position: relative; overflow: hidden;
        border-bottom: 1px solid #e5e7eb;
    }
    .photo-area.drag-over { background-color: #eff6ff; outline: 3px dashed #2563eb; }
    
    .grid-cell { position: absolute; overflow: hidden; background: #ddd; transition: 0.3s; cursor: grab; border: 1px solid white;}
    .grid-cell img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
    .remove-btn { position: absolute; top: 4px; right: 4px; padding: 4px; background: #ef4444; color: white; border: none; border-radius: 50%; cursor: pointer; opacity: 0; z-index: 10; width: 20px; height: 20px; display:flex; align-items:center; justify-content:center; font-size: 12px; line-height: 1;}
    .grid-cell:hover .remove-btn { opacity: 1; }

    /* BOTTOM: CALENDAR GRID */
    .calendar-area {
        height: 40%; width: 100%; padding: 20px; display: flex; flex-direction: column;
    }
    .month-title { font-size: 32px; font-weight: 300; text-transform: uppercase; color: #111827; margin-bottom: 10px; text-align: center; letter-spacing: 2px;}
    
    .cal-grid { display: flex; flex-direction: column; flex: 1; border-top: 2px solid #111827; }
    .cal-row { display: flex; flex: 1; border-bottom: 1px solid #e5e7eb; }
    .cal-row.header { flex: 0 0 30px; border-bottom: 1px solid #9ca3af; font-weight: 600; font-size: 12px; text-transform: uppercase; color: #4b5563; align-items: center; }
    .cal-cell { flex: 1; border-right: 1px solid #e5e7eb; padding: 4px; position: relative; display: flex; flex-direction: column; }
    .cal-cell:last-child { border-right: none; }
    
    .cal-date-row { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 2px; }
    .cal-date { font-size: 14px; font-weight: 600; color: #111827; }
    .holiday-name { font-size: 9px; color: #dc2626; font-weight: 600; text-transform: uppercase; text-align: right; line-height: 1.1; max-width: 70%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    
    .cal-input { 
        flex: 1; border: none; font-family: inherit; font-size: 11px; color: #4b5563; resize: none; background: transparent; outline: none; width: 100%; 
        line-height: 1.2;
    }
    .cal-input::placeholder { color: #d1d5db; font-style: italic; }
    .weekend { background-color: #f9fafb; }
    .red-day .cal-date { color: #dc2626; }

    /* Dragging Visuals */
    .dragging { opacity: 0.5; }

    @media (max-width: 1100px) {
        .a4-page { transform: scale(0.7); margin-bottom: -300px; }
    }
  </style>
  
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
</head>
<body>

  <div class="sidebar">
    <div class="sidebar-header">
      <h1>Fotogrid Kalender</h1>
      <span class="version-tag">Versjon 2.1 (HEIC)</span>
      <p style="margin-top:5px;">Dra bilder til månedene</p>
    </div>
    <div class="sidebar-content">
      <div>
        <label>Prosjektnavn</label>
        <input type="text" id="projectName" placeholder="Min Kalender 2026" onchange="saveData()">
      </div>
      
      <div style="border-top:1px solid #eee; padding-top:10px;">
        <label>Avstand bilder (mm): <span id="gapVal" class="slider-val">2</span></label>
        <input type="range" id="gapInput" min="0" max="10" step="0.5" value="2" oninput="updateSettings()">
        
        <label style="margin-top:10px;">Marg/Kant (mm): <span id="padVal" class="slider-val">0</span></label>
        <input type="range" id="padInput" min="0" max="30" step="1" value="0" oninput="updateSettings()">
      </div>

      <div style="border-top:1px solid #eee; padding-top:10px;">
        <label>Bildebank</label>
        <button id="uploadBtn" class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
          + Last opp bilder
        </button>
        <input type="file" id="fileInput" accept="image/*,.heic,.HEIC" multiple style="display:none">
      </div>
      
      <div>
        <button class="btn btn-danger" onclick="clearAll()">Tøm alt</button>
      </div>
    </div>
    <div class="sidebar-footer">
      <button id="exportBtn" class="btn btn-primary" onclick="exportCalendar()">
        Last ned Kalender (ZIP)
      </button>
      <p style="margin-top:10px; font-size:11px; text-align:center;">Format: A4, 300 DPI</p>
    </div>
  </div>

  <div class="main-area">
    
    <div class="inbox-container">
        <div class="inbox-header">
            <span>Bildebank</span>
            <span id="inboxCount">0 bilder</span>
        </div>
        <div id="inboxScroll" class="inbox-scroll" ondragover="handleDragOver(event)" ondrop="handleDropToInbox(event)">
            </div>
    </div>

    <div id="calendarScroll" class="calendar-scroll-area">
        </div>

  </div>

  <script>
    // --- DATA MODEL ---
    const MONTH_NAMES = ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"];
    const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    
    const HOLIDAYS_2026 = {
        "0-1": "1. nyttårsdag",
        "2-29": "Palmesøndag",
        "3-2": "Skjærtorsdag",
        "3-3": "Langfredag",
        "3-5": "1. påskedag",
        "3-6": "2. påskedag",
        "4-1": "Arbeidernes dag",
        "4-14": "Kr. himmelfart",
        "4-17": "Grunnlovsdag",
        "4-24": "1. pinsedag",
        "4-25": "2. pinsedag",
        "11-25": "1. juledag",
        "11-26": "2. juledag"
    };

    let photoLibrary = []; 
    let inboxIds = []; 
    let monthData = Array(12).fill(null).map(() => ({ 
        photoIds: [], 
        texts: {} 
    }));

    let settings = {
        gapMM: 2,
        padMM: 0
    };

    // --- DB SETUP ---
    const dbName = "Cal2026DB_v2";
    let db;
    
    async function initDB() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(dbName, 1);
            req.onupgradeneeded = e => {
                const db = e.target.result;
                if(!db.objectStoreNames.contains('photos')) db.createObjectStore('photos', {keyPath: 'id'});
                if(!db.objectStoreNames.contains('state')) db.createObjectStore('state', {keyPath: 'id'});
            };
            req.onsuccess = e => { db = e.target.result; resolve(); };
            req.onerror = e => reject(e);
        });
    }

    // --- INITIALIZATION ---
    (async function start() {
        await initDB();
        await loadData();
        
        document.getElementById('gapInput').value = settings.gapMM;
        document.getElementById('gapVal').textContent = settings.gapMM;
        document.getElementById('padInput').value = settings.padMM;
        document.getElementById('padVal').textContent = settings.padMM;

        renderInbox();
        renderCalendarPages();
    })();

    // --- RENDER LOGIC ---
    function updateSettings() {
        const gap = parseFloat(document.getElementById('gapInput').value);
        const pad = parseFloat(document.getElementById('padInput').value);
        
        settings.gapMM = gap;
        settings.padMM = pad;
        
        document.getElementById('gapVal').textContent = gap;
        document.getElementById('padVal').textContent = pad;

        for (let m = 0; m < 12; m++) {
            updateMonthGridLayout(m);
        }
        saveStateDebounced();
    }

    function renderInbox() {
        const container = document.getElementById('inboxScroll');
        container.innerHTML = '';
        document.getElementById('inboxCount').textContent = inboxIds.length + " bilder";

        inboxIds.forEach(id => {
            const photo = photoLibrary.find(p => p.id === id);
            if (!photo) return;
            
            const div = document.createElement('div');
            div.className = 'inbox-photo';
            div.draggable = true;
            div.ondragstart = (e) => dragStart(e, id, 'inbox');
            
            div.innerHTML = `<img src="${photo.src}">`;
            container.appendChild(div);
        });
    }

    function renderCalendarPages() {
        const container = document.getElementById('calendarScroll');
        container.innerHTML = '';

        for (let m = 0; m < 12; m++) {
            container.appendChild(createPageElement(m));
        }
        for (let m = 0; m < 12; m++) {
            updateMonthGridLayout(m);
        }
    }

    function createPageElement(monthIndex) {
        const page = document.createElement('div');
        page.className = 'a4-page';
        page.id = `page-${monthIndex}`;

        const photoArea = document.createElement('div');
        photoArea.className = 'photo-area';
        photoArea.id = `photo-area-${monthIndex}`;
        photoArea.ondragover = handleDragOver;
        photoArea.ondrop = (e) => handleDropToMonth(e, monthIndex);
        
        const calArea = document.createElement('div');
        calArea.className = 'calendar-area';
        
        const title = document.createElement('div');
        title.className = 'month-title';
        title.textContent = `${MONTH_NAMES[monthIndex]} 2026`;
        
        const grid = createCalendarGrid(monthIndex);
        
        calArea.appendChild(title);
        calArea.appendChild(grid);
        
        page.appendChild(photoArea);
        page.appendChild(calArea);
        
        return page;
    }

    function createCalendarGrid(monthIndex) {
        const grid = document.createElement('div');
        grid.className = 'cal-grid';

        const header = document.createElement('div');
        header.className = 'cal-row header';
        ['Man', 'Tir', 'Ons', 'Tor', 'Fre', 'Lør', 'Søn'].forEach(day => {
            const cell = document.createElement('div');
            cell.className = 'cal-cell';
            cell.textContent = day;
            cell.style.textAlign = 'center';
            header.appendChild(cell);
        });
        grid.appendChild(header);

        const firstDayDate = new Date(2026, monthIndex, 1);
        let startDay = firstDayDate.getDay(); 
        if (startDay === 0) startDay = 7; 
        
        const totalDays = DAYS_IN_MONTH[monthIndex];
        let currentDay = 1;
        
        for (let r = 0; r < 6; r++) {
            if (currentDay > totalDays) break;
            const row = document.createElement('div');
            row.className = 'cal-row';
            
            for (let d = 1; d <= 7; d++) {
                const cell = document.createElement('div');
                cell.className = 'cal-cell';
                
                if (r === 0 && d < startDay) {
                    cell.style.background = '#f9fafb';
                } else if (currentDay <= totalDays) {
                    const holidayName = HOLIDAYS_2026[`${monthIndex}-${currentDay}`];
                    const isSunday = (d === 7);
                    
                    if (d === 6 || d === 7) cell.className += " weekend";
                    if (holidayName || isSunday) cell.className += " red-day";
                    
                    const dateRow = document.createElement('div');
                    dateRow.className = 'cal-date-row';
                    
                    const dateNum = document.createElement('div');
                    dateNum.className = 'cal-date';
                    dateNum.textContent = currentDay;
                    dateRow.appendChild(dateNum);

                    if(holidayName) {
                        const hTag = document.createElement('div');
                        hTag.className = 'holiday-name';
                        hTag.textContent = holidayName;
                        dateRow.appendChild(hTag);
                    }
                    cell.appendChild(dateRow);
                    
                    const input = document.createElement('textarea');
                    input.className = 'cal-input';
                    input.placeholder = "Notat...";
                    input.dataset.month = monthIndex;
                    input.dataset.day = currentDay;
                    if (monthData[monthIndex].texts[currentDay]) {
                        input.value = monthData[monthIndex].texts[currentDay];
                    }
                    input.oninput = (e) => {
                        monthData[monthIndex].texts[e.target.dataset.day] = e.target.value;
                        saveStateDebounced();
                    };

                    cell.appendChild(input);
                    currentDay++;
                } else {
                    cell.style.background = '#f9fafb';
                }
                row.appendChild(cell);
            }
            grid.appendChild(row);
        }
        return grid;
    }

    function updateMonthGridLayout(mIndex) {
        const area = document.getElementById(`photo-area-${mIndex}`);
        area.innerHTML = '';
        
        const photoIds = monthData[mIndex].photoIds;
        if (photoIds.length === 0) {
            area.innerHTML = `<div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; color:#9ca3af; font-size:14px;">Dra bilder hit</div>`;
            return;
        }

        const photos = photoIds.map(id => photoLibrary.find(p => p.id === id)).filter(p => p);
        
        const pxPerMm = 3.7795;
        const totalW = 794;
        const totalH = 673; 
        const padPx = settings.padMM * pxPerMm;
        const gapPx = settings.gapMM * pxPerMm;

        const effectiveW = totalW - (padPx * 2);
        const effectiveH = totalH - (padPx * 2);

        if (effectiveW < 50 || effectiveH < 50) return;

        const layout = calculateOptimalGrid(photos, effectiveW, effectiveH, gapPx);

        layout.cells.forEach(cell => {
            const div = document.createElement('div');
            div.className = 'grid-cell';
            div.style.left = (cell.x + padPx) + 'px';
            div.style.top = (cell.y + padPx) + 'px';
            div.style.width = cell.width + 'px';
            div.style.height = cell.height + 'px';
            
            div.draggable = true;
            div.ondragstart = (e) => dragStart(e, cell.photo.id, 'month', mIndex);

            div.innerHTML = `
                <img src="${cell.photo.src}">
                <button class="remove-btn" onclick="sendToInbox('${cell.photo.id}', ${mIndex})">×</button>
            `;
            area.appendChild(div);
        });
    }

    function calculateOptimalGrid(photos, width, height, gap) {
        if (photos.length === 0) return { cells: [] };
        
        let bestLayout = null;
        let bestScore = Infinity;

        for (let rows = 1; rows <= photos.length; rows++) {
            const result = generateRows(photos, rows, width, gap);
            const contentHeight = result.totalHeight;
            const scale = height / contentHeight;
            let score = Math.abs(1 - scale);
            if (scale > 1.5 || scale < 0.5) score += 10;

            if (score < bestScore) {
                bestScore = score;
                bestLayout = { ...result, fitScale: scale };
            }
        }
        
        const cells = [];
        let yOffset = 0;
        const rows = bestLayout.rows;
        let totalH = bestLayout.totalHeight;
        
        let scaleFactor = height / totalH; 

        rows.forEach(row => {
            let xOffset = 0;
            const rowHeight = row.height * scaleFactor;
            
            row.photos.forEach(photo => {
                const cellW = (width - (row.photos.length - 1) * gap) * (photo.ratio / row.aspectSum);
                
                cells.push({
                    x: xOffset,
                    y: yOffset,
                    width: cellW,
                    height: rowHeight - gap, 
                    photo: photo
                });
                xOffset += cellW + gap;
            });
            yOffset += rowHeight; 
        });

        return { cells };
    }

    function generateRows(photos, numRows, width, gap) {
        const base = Math.floor(photos.length / numRows);
        const extra = photos.length % numRows;
        
        let pIdx = 0;
        const rows = [];
        let totalHeight = 0;

        for (let r = 0; r < numRows; r++) {
            const count = base + (r < extra ? 1 : 0);
            const rowPhotos = [];
            let aspectSum = 0;
            for (let i = 0; i < count; i++) {
                rowPhotos.push(photos[pIdx]);
                aspectSum += photos[pIdx].ratio;
                pIdx++;
            }
            const wAvailable = width - (count - 1) * gap;
            const h = wAvailable / aspectSum;
            
            rows.push({ photos: rowPhotos, height: h, aspectSum });
            totalHeight += h;
        }
        return { rows, totalHeight };
    }

    // --- DRAG AND DROP ---
    let dragData = null; 

    function dragStart(e, id, source, mIndex) {
        dragData = { id, source, monthIndex: mIndex };
        e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }

    function handleDropToMonth(e, targetMonthIndex) {
        e.preventDefault();
        if (!dragData) return;
        
        const { id, source, monthIndex } = dragData;
        
        if (source === 'inbox') {
            inboxIds = inboxIds.filter(x => x !== id);
            monthData[targetMonthIndex].photoIds.push(id);
        } else if (source === 'month') {
            monthData[monthIndex].photoIds = monthData[monthIndex].photoIds.filter(x => x !== id);
            monthData[targetMonthIndex].photoIds.push(id);
        }
        
        renderInbox();
        updateMonthGridLayout(targetMonthIndex);
        if (source === 'month' && monthIndex !== targetMonthIndex) updateMonthGridLayout(monthIndex);
        saveState();
        dragData = null;
    }

    function handleDropToInbox(e) {
        e.preventDefault();
        if (!dragData) return;
        const { id, source, monthIndex } = dragData;
        
        if (source === 'month') {
            monthData[monthIndex].photoIds = monthData[monthIndex].photoIds.filter(x => x !== id);
            inboxIds.push(id);
            renderInbox();
            updateMonthGridLayout(monthIndex);
            saveState();
        }
        dragData = null;
    }

    function sendToInbox(id, mIndex) {
        monthData[mIndex].photoIds = monthData[mIndex].photoIds.filter(x => x !== id);
        inboxIds.push(id);
        renderInbox();
        updateMonthGridLayout(mIndex);
        saveState();
    }

    // --- FILE HANDLING (UPDATED FOR HEIC) ---
    document.getElementById('fileInput').addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;

        const uploadBtn = document.getElementById('uploadBtn');
        const originalBtnText = uploadBtn.innerText;
        uploadBtn.innerText = "Behandler...";
        uploadBtn.disabled = true;

        for (const file of files) {
            let processedBlob = file;
            let fileName = file.name.toLowerCase();

            // HEIC CONVERSION LOGIC
            if (fileName.endsWith('.heic') || file.type === "image/heic" || file.type === "image/heif") {
                try {
                    uploadBtn.innerText = "Konverterer HEIC...";
                    // heic2any returns a blob or array of blobs. We assume single.
                    const result = await heic2any({ blob: file, toType: "image/jpeg", quality: 0.8 });
                    processedBlob = Array.isArray(result) ? result[0] : result;
                } catch (err) {
                    console.error("HEIC konvertering feilet for", file.name, err);
                    alert("Kunne ikke konvertere " + file.name + ". Prøv et annet bilde.");
                    continue;
                }
            }

            const id = Date.now() + Math.random().toString();
            const src = URL.createObjectURL(processedBlob);
            
            const img = new Image();
            img.src = src;
            await new Promise(r => img.onload = r);
            const ratio = img.width / img.height;

            const photo = { id, src, file: processedBlob, ratio };
            photoLibrary.push(photo);
            inboxIds.push(id);
            
            const tx = db.transaction('photos', 'readwrite');
            tx.objectStore('photos').put({id, file: processedBlob, ratio});
        }
        
        renderInbox();
        saveState();
        uploadBtn.innerText = originalBtnText;
        uploadBtn.disabled = false;
    });

    // --- PERSISTENCE ---
    function saveState() {
        if (!db) return;
        const tx = db.transaction('state', 'readwrite');
        tx.objectStore('state').put({
            id: 'current',
            inboxIds: inboxIds,
            monthData: monthData,
            projectName: document.getElementById('projectName').value,
            settings: settings
        });
    }
    
    let saveTimeout;
    function saveStateDebounced() {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(saveState, 1000);
    }

    async function loadData() {
        if (!db) return;
        const txP = db.transaction('photos', 'readonly');
        const allPhotos = await new Promise(resolve => {
            const req = txP.objectStore('photos').getAll();
            req.onsuccess = () => resolve(req.result);
        });
        
        photoLibrary = allPhotos.map(p => ({
            id: p.id,
            src: URL.createObjectURL(p.file),
            file: p.file,
            ratio: p.ratio
        }));

        const txS = db.transaction('state', 'readonly');
        const state = await new Promise(resolve => {
            const req = txS.objectStore('state').get('current');
            req.onsuccess = () => resolve(req.result);
        });

        if (state) {
            const libIds = new Set(photoLibrary.map(p => p.id));
            inboxIds = state.inboxIds.filter(id => libIds.has(id));
            monthData = state.monthData.map(m => ({
                photoIds: m.photoIds.filter(id => libIds.has(id)),
                texts: m.texts || {}
            }));
            document.getElementById('projectName').value = state.projectName || "";
            if(state.settings) settings = state.settings;
        }
    }

    async function clearAll() {
        if(!confirm("Slett alt innhold?")) return;
        const tx = db.transaction(['photos', 'state'], 'readwrite');
        tx.objectStore('photos').clear();
        tx.objectStore('state').clear();
        location.reload();
    }

    // --- EXPORT LOGIC ---
    async function exportCalendar() {
        const btn = document.getElementById('exportBtn');
        btn.textContent = "Genererer...";
        btn.disabled = true;

        const zip = new JSZip();
        const projectName = document.getElementById('projectName').value || "Kalender2026";
        
        const exportW = 2480;
        const exportH = 3508;
        
        const pxPerMmExport = 11.811;
        const gapExport = settings.gapMM * pxPerMmExport;
        const padExport = settings.padMM * pxPerMmExport;

        const canvas = document.createElement('canvas');
        canvas.width = exportW;
        canvas.height = exportH;
        const ctx = canvas.getContext('2d');

        try {
            for (let m = 0; m < 12; m++) {
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, exportW, exportH);
                
                const photoIds = monthData[m].photoIds;
                if (photoIds.length > 0) {
                    const photos = photoIds.map(id => photoLibrary.find(p => p.id === id));
                    const totalAreaH = exportH * 0.6;
                    
                    const effW = exportW - (padExport * 2);
                    const effH = totalAreaH - (padExport * 2);

                    if (effW > 100 && effH > 100) {
                        const layout = calculateOptimalGrid(photos, effW, effH, gapExport);
                        
                        for (const cell of layout.cells) {
                            const img = new Image();
                            img.src = cell.photo.src;
                            await new Promise(r => img.onload = r);
                            
                            const cx = cell.x + padExport;
                            const cy = cell.y + padExport;
                            const cw = cell.width;
                            const ch = cell.height;
                            
                            let sWidth = img.width;
                            let sHeight = img.height;
                            let sx = 0; let sy = 0;
                            const aspectImg = sWidth / sHeight;
                            const aspectRect = cw / ch;
                            
                            if (aspectImg > aspectRect) {
                                const newSW = sHeight * aspectRect;
                                sx = (sWidth - newSW) / 2;
                                sWidth = newSW;
                            } else {
                                const newSH = sWidth / aspectRect;
                                sy = (sHeight - newSH) / 2;
                                sHeight = newSH;
                            }
                            
                            ctx.drawImage(img, sx, sy, sWidth, sHeight, cx, cy, cw, ch);
                        }
                    }
                }

                const startY = exportH * 0.6;
                const calH = exportH * 0.4;
                const margin = 120; 
                const contentW = exportW - (margin*2);
                
                ctx.fillStyle = "#111827";
                ctx.font = "300 100px sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                ctx.fillText(MONTH_NAMES[m].toUpperCase() + " 2026", exportW/2, startY + 40);

                const gridY = startY + 180;
                const gridH = calH - 250;
                const cellW = contentW / 7;
                const cellH = gridH / 7; 
                
                ctx.lineWidth = 4;
                ctx.strokeStyle = "#111827";
                
                ctx.font = "600 40px sans-serif";
                const days = ['MAN', 'TIR', 'ONS', 'TOR', 'FRE', 'LØR', 'SØN'];
                for(let i=0; i<7; i++) {
                    const x = margin + (i * cellW) + (cellW/2);
                    ctx.fillText(days[i], x, gridY + 20);
                }
                
                ctx.beginPath();
                ctx.moveTo(margin, gridY + 80);
                ctx.lineTo(exportW - margin, gridY + 80);
                ctx.stroke();

                ctx.font = "600 50px sans-serif";
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#e5e7eb";

                const firstDate = new Date(2026, m, 1);
                let startDay = firstDate.getDay(); if(startDay===0) startDay=7;
                let dayCounter = 1;
                const daysTotal = DAYS_IN_MONTH[m];

                for (let r = 0; r < 6; r++) {
                    const y = gridY + 80 + (r * cellH);
                    
                    if (r > 0) {
                        ctx.beginPath(); ctx.moveTo(margin, y); ctx.lineTo(exportW-margin, y); ctx.stroke();
                    }

                    for (let d = 0; d < 7; d++) {
                        if (d > 0) {
                            const x = margin + (d * cellW);
                            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + cellH); ctx.stroke();
                        }
                        
                        if ((r===0 && d+1 < startDay) || dayCounter > daysTotal) {
                            // empty
                        } else {
                            const cx = margin + (d * cellW);
                            const cy = y;
                            const holidayName = HOLIDAYS_2026[`${m}-${dayCounter}`];
                            
                            ctx.fillStyle = "#111827";
                            if (d >= 5 || holidayName) ctx.fillStyle = "#dc2626"; 
                            ctx.textAlign = "left";
                            ctx.font = "600 50px sans-serif";
                            ctx.fillText(dayCounter, cx + 15, cy + 15);
                            
                            if (holidayName) {
                                ctx.font = "600 24px sans-serif";
                                ctx.textAlign = "right";
                                ctx.fillText(holidayName, cx + cellW - 10, cy + 15);
                            }

                            const userText = monthData[m].texts[dayCounter];
                            if (userText) {
                                ctx.fillStyle = "#4b5563";
                                ctx.font = "400 30px sans-serif"; 
                                ctx.textAlign = "left";
                                wrapText(ctx, userText, cx + 15, cy + 80, cellW - 30, 40);
                            }

                            dayCounter++;
                        }
                    }
                }
                
                ctx.strokeStyle = "#111827";
                ctx.lineWidth = 4;
                ctx.strokeRect(margin, gridY, contentW, gridH);

                const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.9));
                zip.file(`${m+1}_${MONTH_NAMES[m]}.jpg`, blob);
            }
            
            const content = await zip.generateAsync({type:"blob"});
            const a = document.createElement("a");
            a.href = URL.createObjectURL(content);
            a.download = `${projectName}.zip`;
            a.click();

        } catch (e) {
            console.error(e);
            alert("Feil under eksport: " + e.message);
        } finally {
            btn.textContent = "Last ned Kalender (ZIP)";
            btn.disabled = false;
        }
    }

    function wrapText(context, text, x, y, maxWidth, lineHeight) {
        const words = text.split(' ');
        let line = '';

        for(let n = 0; n < words.length; n++) {
          const testLine = line + words[n] + ' ';
          const metrics = context.measureText(testLine);
          const testWidth = metrics.width;
          if (testWidth > maxWidth && n > 0) {
            context.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
          }
          else {
            line = testLine;
          }
        }
        context.fillText(line, x, y);
    }

  </script>
</body>
</html>
