<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Instagram Maler (Oppdatert)</title>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #fafafa; color: #111827; }
    .app-container { min-height: 100vh; display: flex; }
    .sidebar { width: 320px; background-color: white; border-right: 1px solid #dbdbdb; display: flex; flex-direction: column; }
    .sidebar-header { padding: 24px; border-bottom: 1px solid #dbdbdb; }
    .sidebar-header h1 { font-size: 24px; font-weight: 600; color: #111827; margin-bottom: 4px; }
    .sidebar-header p { font-size: 14px; color: #8e8e8e; }
    .sidebar-content { flex: 1; overflow-y: auto; padding: 24px; display: flex; flex-direction: column; gap: 24px; }
    .sidebar-footer { padding: 24px; border-top: 1px solid #dbdbdb; }
    .control-group { display: flex; flex-direction: column; gap: 8px; }
    .control-group label { font-size: 14px; font-weight: 500; color: #262626; }
    .photo-count { font-size: 12px; color: #8e8e8e; margin-top: 8px; }
    .btn-primary { width: 100%; padding: 12px 16px; background-color: #0095f6; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 8px; justify-content: center; font-size: 14px; }
    .btn-primary:hover { background-color: #1877f2; }
    .btn-danger { width: 100%; padding: 8px 16px; color: #ed4956; background-color: white; border: 1px solid #ed4956; border-radius: 8px; cursor: pointer; font-weight: 600; }
    .btn-danger:hover { background-color: #fef2f2; }
    .btn-export { width: 100%; padding: 12px 16px; background-color: #262626; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 8px; justify-content: center; }
    .btn-export:hover { background-color: #000000; }
    .btn-export:disabled { opacity: 0.5; cursor: not-allowed; }
    .button-group { display: flex; gap: 8px; flex-wrap: wrap; }
    .button-group button { flex: 1; min-width: 80px; padding: 8px 12px; background-color: white; color: #262626; border: 1px solid #dbdbdb; border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 500; }
    .button-group button:hover { border-color: #8e8e8e; }
    .button-group button.active { background-color: #0095f6; border-color: #0095f6; color: white; }
    select { width: 100%; padding: 8px 12px; border: 1px solid #dbdbdb; border-radius: 8px; font-size: 14px; outline: none; }
    select:focus { border-color: #0095f6; }
    input[type="text"], input[type="number"] { width: 100%; padding: 8px 12px; border: 1px solid #dbdbdb; border-radius: 8px; font-size: 14px; outline: none; }
    input[type="text"]:focus, input[type="number"]:focus { border-color: #0095f6; }
    .main-canvas { flex: 1; display: flex; flex-direction: column; align-items: center; padding: 40px 20px; background: #fafafa; gap: 40px; }
    .main-canvas.hidden { display: none; }
    .instagram-frame { background: white; border: 1px solid #dbdbdb; border-radius: 12px; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.08); width: fit-content; max-width: 100%; }
    .frame-header { padding: 12px 16px; border-bottom: 1px solid #dbdbdb; display: flex; align-items: center; gap: 12px; background: white; flex-shrink: 0; }
    .post-avatar { width: 32px; height: 32px; border-radius: 50%; background: linear-gradient(45deg, #f09433 0%,#e6683c 25%,#dc2743 50%,#cc2366 75%,#bc1888 100%); flex-shrink: 0; }
    .post-username { font-size: 14px; font-weight: 600; color: #262626; }
    .frame-content { overflow: hidden; user-select: none; position: relative; flex-shrink: 0; }
    .images-container { display: flex; height: 100%; position: absolute; left: 0; top: 0; transition: transform 0.3s ease; }
    .post-image { flex-shrink: 0; display: flex; align-items: center; justify-content: center; background: #fff; position: relative; }
    .post-image img { display: block; object-fit: cover; }
    .carousel-indicators { position: absolute; top: 8px; right: 8px; background: rgba(0,0,0,0.5); color: white; padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; z-index: 10; }
    .post-actions { padding: 12px 16px; display: flex; gap: 16px; border-top: 1px solid #efefef; }
    .post-action { width: 24px; height: 24px; cursor: pointer; }
    .preview-section { width: 100%; max-width: 935px; }
    .preview-feed { background: #fafafa; border: none; border-radius: 0; padding: 0; box-shadow: none; max-width: 935px; margin: 0 auto; }
    .preview-grid-nav { display: flex; justify-content: space-around; align-items: center; border-top: 1px solid #dbdbdb; background: white; }
    .preview-grid-nav-item { flex: 1; display: flex; justify-content: center; padding: 12px 0; cursor: pointer; color: #8e8e8e; border-bottom: 2px solid transparent; transition: color 0.1s; }
    .preview-grid-nav-item.active { color: #262626; border-bottom: 2px solid #262626; }
    .preview-grid-nav-item svg { width: 24px; height: 24px; stroke: currentColor; }
    .preview-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; width: 100%; padding: 4px 0; }
    .preview-post { aspect-ratio: 4 / 5; background: #fff; position: relative; overflow: hidden; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .preview-post img { object-fit: cover; display: block; width: 100%; height: 100%; }
    .preview-post.new-post { box-shadow: 0 0 0 2px #fff, 0 0 0 4px #dbdbdb; }
    .preview-post.new-post::after { content: 'NYT'; position: absolute; top: 8px; right: 8px; background: #0095f6; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; z-index: 1; }
    .preview-carousel-indicator { position: absolute; top: 8px; right: 8px; background: rgba(0,0,0,0.5); color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: 600; }
    .loading { text-align: center; padding: 40px; color: #8e8e8e; }
    .error { text-align: center; padding: 20px; color: #ed4956; }
    .preview-feed .non-square-post { grid-column: span 3; margin-bottom: 4px; aspect-ratio: 9 / 16; }
    .username-input-group { display: flex; gap: 8px; }
    .btn-load { padding: 8px 16px; background-color: #0095f6; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; white-space: nowrap; }
    .btn-load:hover { background-color: #1877f2; }
    .btn-load:disabled { opacity: 0.5; cursor: not-allowed; }
    .placeholder { background: #e3e3e3; }

    @media (max-width: 900px) {
      .app-container { flex-direction: column; }
      .sidebar { width: 100%; border-right: none; border-bottom: 1px solid #dbdbdb; }
      .main-canvas { padding: 20px; }
      .instagram-frame { max-width: 100%; }
      .preview-grid { grid-template-columns: repeat(3, 1fr) !important; }
    }
  </style>
</head>
<body onload="initApp()">
  <div class="app-container">
    <div class="sidebar">
      <div class="sidebar-header">
        <h1>Instagram Maler</h1>
        <p>Lag innlegg for Instagram</p>
      </div>

      <div class="sidebar-content">
        <div class="control-group">
          <label>Bilder</label>
          <input type="file" id="fileInput" accept="image/*" multiple style="display: none">
          <button class="btn-primary" onclick="document.getElementById('fileInput').click()">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
              <circle cx="8.5" cy="8.5" r="1.5"></circle>
              <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
            Last opp bilder
          </button>
          <p class="photo-count"><span id="photoCount">0</span> bilder lastet opp</p>
        </div>

        <div class="control-group">
          <label>Instagram Innlegg Format</label>
          <div class="button-group">
            <button onclick="setFormat('portrait')" class="active">4:5<br>Portrett</button>
            <button onclick="setFormat('landscape')">16:9<br>Landskap</button>
            <button onclick="setFormat('wide')">3:2<br>Bred</button>
            <button onclick="setFormat('square')">1:1<br>Kvadrat</button>
            <button onclick="setFormat('story')">9:16<br>Historie</button>
          </div>
        </div>

        <div class="control-group">
          <label>Del bilder (split i to innlegg)</label>
          <div style="display: flex; gap: 8px;">
            <input type="text" id="panoramaImages" placeholder="F.eks: 1, 3, 5" style="flex: 1;">
            <button class="btn-load" onclick="updatePanoramaMode()">Oppdater</button>
          </div>
          <p class="photo-count" style="font-size: 11px; margin-top: 4px;">Skriv inn bildenummer som skal deles i to separate innlegg</p>
        </div>

        <div class="control-group">
          <label>Ramme rundt bilde: <span id="frameMarginValue">0</span>mm</label>
          <div style="display: flex; gap: 8px; align-items: center;">
            <input type="range" id="frameMargin" min="0" max="50" value="0" oninput="updateMargin()" style="flex: 1;">
            <input type="number" id="frameMarginInput" min="0" max="50" value="0" oninput="updateMarginFromInput()" style="width: 60px; padding: 4px 8px; border: 1px solid #dbdbdb; border-radius: 6px;">
          </div>
        </div>

        <div class="control-group">
          <label>Eksport kvalitet</label>
          <select id="quality">
            <option value="0.92">Høy kvalitet (anbefalt)</option>
            <option value="0.85">Medium kvalitet</option>
            <option value="0.75">Lav kvalitet (mindre filer)</option>
          </select>
        </div>

        <div class="control-group">
          <label>Instagram brukernavn (valgfritt)</label>
          <div class="username-input-group">
            <input type="text" id="usernameInput" placeholder="brukernavn">
            <button class="btn-load" id="loadFeedBtn" onclick="loadInstagramFeed()">Last inn</button>
          </div>
          <p class="photo-count" style="font-size: 11px;">Laster inn offentlige profiler for forhåndsvisning (dette vil ikke påvirke profilruten nede)</p>
        </div>

        <button id="clearBtn" class="btn-danger" onclick="clearAll()" style="display:none">Fjern alle bilder</button>
      </div>

      <div class="sidebar-footer">
        <button id="exportInstagramBtn" class="btn-export" onclick="exportInstagramPosts()" disabled>
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          Eksporter Innlegg (ZIP)
        </button>
      </div>
    </div>

    <div id="mainCanvas" class="main-canvas hidden">
      <div class="instagram-frame">
        <div class="frame-header">
          <div class="post-avatar"></div>
          <span class="post-username" id="frameUsername">din_profil</span>
        </div>
        <div id="frameContent" class="frame-content">
          <div id="imagesContainer" class="images-container"></div>
        </div>
        <div class="post-actions">
          <svg class="post-action" viewBox="0 0 24 24" fill="none" stroke="#262626" stroke-width="2">
            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
          </svg>
          <svg class="post-action" viewBox="0 0 24 24" fill="none" stroke="#262626" stroke-width="2">
            <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
          </svg>
          <svg class="post-action" viewBox="0 0 24 24" fill="none" stroke="#262626" stroke-width="2">
            <line x1="22" y1="2" x2="11" y2="13"></line>
            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
          </svg>
        </div>
      </div>

      <div id="previewSection" class="preview-section">
        <div class="preview-feed">
          <div class="preview-grid-nav">
              <div class="preview-grid-nav-item active">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                      <line x1="12" y1="3" x2="12" y2="21"></line>
                      <line x1="3" y1="12" x2="21" y2="12"></line>
                  </svg>
              </div>
              <div class="preview-grid-nav-item">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <circle cx="12" cy="12" r="10"></circle>
                      <polygon points="10 8 16 12 10 16 10 8"></polygon>
                  </svg>
              </div>
              <div class="preview-grid-nav-item">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                      <polyline points="17 8 12 3 7 8"></polyline>
                      <line x1="12" y1="3" x2="12" y2="15"></line>
                  </svg>
              </div>
          </div>

          <div id="previewGrid" class="preview-grid"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const FORMATS = {
      square: { width: 1, height: 1 },
      portrait: { width: 4, height: 5 },
      landscape: { width: 16, height: 9 },
      wide: { width: 3, height: 2 },
      story: { width: 9, height: 16 }
    };

    let photos = [];
    let currentFormat = 'portrait';
    let instagramFeed = [];
    let panoramaImages = new Set();

    document.getElementById('fileInput').addEventListener('change', handleFileUpload);

    function initApp() {
        loadStandardFeed();
        updateUI();
    }

    function updateMargin() {
      const value = document.getElementById('frameMargin').value;
      document.getElementById('frameMarginValue').textContent = value;
      document.getElementById('frameMarginInput').value = value;
      renderFeed();
      renderPreview();
    }

    function updateMarginFromInput() {
      const value = document.getElementById('frameMarginInput').value;
      document.getElementById('frameMarginValue').textContent = value;
      document.getElementById('frameMargin').value = value;
      renderFeed();
      renderPreview();
    }

    function setFormat(format) {
      currentFormat = format;
      document.querySelectorAll('.button-group button').forEach(btn => btn.classList.remove('active'));
      let clickedButton = event.target;
      while (clickedButton && clickedButton.tagName !== 'BUTTON') {
          clickedButton = clickedButton.parentNode;
      }
      if (clickedButton) {
          clickedButton.classList.add('active');
      }

      renderFeed();
      renderPreview();
    }

    // Add window resize listener to update carousel on orientation changes
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (photos.length > 0) {
          renderFeed();
          renderPreview();
        }
      }, 250);
    });

    function handleFileUpload(e) {
      handleFiles(Array.from(e.target.files));
    }

    function handleFiles(files) {
      const loadPromises = files.filter(f => f.type.startsWith('image/')).map(file => {
        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              const aspectRatio = img.width / img.height;
              resolve({
                id: Date.now() + Math.random(),
                src: e.target.result,
                name: file.name,
                width: img.width,
                height: img.height,
                aspectRatio: aspectRatio,
                isLandscape: aspectRatio > 1
              });
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        });
      });

      Promise.all(loadPromises).then(newPhotos => {
        newPhotos.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
        photos.push(...newPhotos);
        updateUI();
      });
    }

    function updatePanoramaMode() {
      const input = document.getElementById('panoramaImages').value;
      const originalPhotoCount = photos.filter(p => !p.isSplitLeft && !p.isSplitRight).length;

      const newPanoramaSet = new Set();

      if (input.trim()) {
        const numbers = input.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n) && n > 0 && n <= originalPhotoCount);
        numbers.forEach(n => newPanoramaSet.add(n));
      }

      const currentIndicesToSplit = [];
      const currentIndicesToUnsplit = [];

      let currentIndex = 0;
      let originalIndexCounter = 0;

      while (currentIndex < photos.length) {
          const photo = photos[currentIndex];
          const isCurrentlySplit = photo.isSplitLeft || photo.isSplitRight;

          if (!isCurrentlySplit) {
              originalIndexCounter++;
              if (newPanoramaSet.has(originalIndexCounter)) {
                  currentIndicesToSplit.push(currentIndex);
              }
              currentIndex++;
          } else if (photo.isSplitLeft) {
              originalIndexCounter++;
              if (!newPanoramaSet.has(originalIndexCounter)) {
                  currentIndicesToUnsplit.push(currentIndex);
              }
              currentIndex += 2;
          }
      }

      currentIndicesToUnsplit.sort((a, b) => b - a).forEach(index => {
          unsplitPhoto(index);
      });

      const currentPhotosAfterUnsplit = [...photos];

      const splitIndicesAfterUnsplit = [];
      let currentIdx = 0;
      let origIdxCounter = 0;

      while (currentIdx < currentPhotosAfterUnsplit.length) {
          const photo = currentPhotosAfterUnsplit[currentIdx];
          if (!photo.isSplitLeft && !photo.isSplitRight) {
              origIdxCounter++;
              if (newPanoramaSet.has(origIdxCounter) && !panoramaImages.has(origIdxCounter)) {
                   splitIndicesAfterUnsplit.push(currentIdx);
              }
              currentIdx++;
          } else {
              origIdxCounter++;
              currentIdx += 2;
          }
      }

      splitIndicesAfterUnsplit.sort((a, b) => b - a).forEach(index => {
          splitPhoto(index);
      });

      panoramaImages = newPanoramaSet;

      renderFeed();
      renderPreview();
    }

    function splitPhoto(index) {
        if (index < 0 || index >= photos.length || photos[index].isSplitLeft || photos[index].isSplitRight) return;

        const photo = photos[index];

        const leftHalf = {
            ...photo,
            id: Date.now() + Math.random(),
            name: photo.name + '_left',
            isSplitLeft: true,
            originalIndex: index,
            splitAspect: photo.aspectRatio / 2,
            splitRatio: `1:${Math.round(1 / (photo.aspectRatio / 2))}`
        };

        const rightHalf = {
            ...photo,
            id: Date.now() + Math.random() + 1,
            name: photo.name + '_right',
            isSplitRight: true,
            originalIndex: index,
            splitAspect: photo.aspectRatio / 2,
            splitRatio: `1:${Math.round(1 / (photo.aspectRatio / 2))}`
        };

        photos.splice(index, 1, leftHalf, rightHalf);
    }

    function unsplitPhoto(index) {
        if (index < 0 || index >= photos.length) return;

        const photo = photos[index];
        let leftIndex = -1, rightIndex = -1;

        if (photo.isSplitLeft && photos[index + 1] && photos[index + 1].isSplitRight) {
            leftIndex = index;
            rightIndex = index + 1;
        } else if (photo.isSplitRight && photos[index - 1] && photos[index - 1].isSplitLeft) {
            leftIndex = index - 1;
            rightIndex = index;
        } else {
            return;
        }

        const leftPhoto = photos[leftIndex];

        const originalPhoto = {
            id: Date.now() + Math.random(),
            src: leftPhoto.src,
            name: leftPhoto.name.replace('_left', ''),
            width: leftPhoto.width,
            height: leftPhoto.height,
            aspectRatio: leftPhoto.aspectRatio,
            isLandscape: leftPhoto.isLandscape
        };

        photos.splice(leftIndex, 2, originalPhoto);
    }

    function clearAll() {
      photos = [];
      instagramFeed = [];
      document.getElementById('panoramaImages').value = '';
      panoramaImages = new Set();
      updateUI();
    }

    function loadStandardFeed() {
      instagramFeed = Array.from({length: 8}, (_, i) => {
        const canvas = document.createElement('canvas');
        canvas.width = 400;
        canvas.height = 400;
        const ctx = canvas.getContext('2d');

        const hue = (i * 45) % 360;
        ctx.fillStyle = `hsl(${hue}, 60%, 75%)`;
        ctx.fillRect(0, 0, 400, 400);
        ctx.fillStyle = `hsl(${hue}, 60%, 65%)`;
        ctx.fillRect(150, 150, 100, 100);

        const imgUrl = canvas.toDataURL('image/png');

        return { id: i, imageUrl: imgUrl, format: 'square' };
      });

      document.getElementById('frameUsername').textContent = 'din_profil';
    }

    function loadInstagramFeed() {
      const username = document.getElementById('usernameInput').value.trim();
      if (!username) {
        alert('Vennligst skriv inn et brukernavn');
        return;
      }

      document.getElementById('frameUsername').textContent = username;

      const btn = document.getElementById('loadFeedBtn');
      const previewSection = document.getElementById('previewSection');
      const previewGrid = document.getElementById('previewGrid');

      btn.disabled = true;
      btn.textContent = 'Laster...';
      previewGrid.innerHTML = '<div class="loading">Laster inn Instagram-feed...</div>';
      previewSection.style.display = 'block';

      setTimeout(() => {
        loadStandardFeed();
        renderPreview();
        btn.disabled = false;
        btn.textContent = 'Last inn';
      }, 800);
    }

    function updateUI() {
      document.getElementById('photoCount').textContent = photos.length;
      document.getElementById('exportInstagramBtn').disabled = photos.length === 0;
      document.getElementById('clearBtn').style.display = photos.length > 0 ? 'block' : 'none';

      const mainCanvas = document.getElementById('mainCanvas');
      if (photos.length > 0) {
        mainCanvas.classList.remove('hidden');
      } else {
        mainCanvas.classList.add('hidden');
      }

      renderFeed();
      renderPreview();
    }

    function getPostDimensions() {
      const baseSize = 1080;
      const format = FORMATS[currentFormat];

      let width, height;

      if (currentFormat === 'story') {
          width = 1080;
          height = 1920;
      } else if (format.width > format.height) {
        width = baseSize;
        height = Math.round(baseSize * format.height / format.width);
      } else if (format.width < format.height) {
        height = baseSize;
        width = Math.round(baseSize * format.width / format.height);
      } else {
        width = baseSize;
        height = baseSize;
      }

      return { width, height };
    }

    function getPhotoDisplayDimensions(photo) {
      const format = FORMATS[currentFormat];

      let displayWidth, displayHeight;

      // Get viewport width for responsive sizing
      const viewportWidth = window.innerWidth;
      const isMobile = viewportWidth <= 900;

      if (currentFormat === 'story') {
          displayWidth = isMobile ? Math.min(320, viewportWidth - 40) : 320;
          displayHeight = Math.round(displayWidth * 16 / 9);
      } else {
          // Base the size on width instead of height for better mobile support
          if (isMobile) {
            displayWidth = Math.min(400, viewportWidth - 40);
          } else {
            displayWidth = 480;
          }
          displayHeight = Math.round(displayWidth * format.height / format.width);
      }

      return { width: displayWidth, height: displayHeight };
    }

    function renderFeed() {
      const imagesContainer = document.getElementById('imagesContainer');
      const frameContent = document.getElementById('frameContent');
      imagesContainer.innerHTML = '';

      if (photos.length === 0) return;

      const photosToRender = photos;

      const marginMm = parseFloat(document.getElementById('frameMargin').value);
      const marginPx = (marginMm / 25.4) * 96;

      const baseDims = getPhotoDisplayDimensions(photosToRender[0]);

      let maxDisplayWidth = baseDims.width;
      let maxDisplayHeight = baseDims.height;

      photosToRender.forEach(p => {
          const dims = getPhotoDisplayDimensions(p);
          if (dims.width > maxDisplayWidth) maxDisplayWidth = dims.width;
          if (dims.height > maxDisplayHeight) maxDisplayHeight = dims.height;
      });

      frameContent.style.width = maxDisplayWidth + 'px';
      frameContent.style.height = maxDisplayHeight + 'px';

      const frameWidth = maxDisplayWidth;
      const displayWidth = frameWidth;
      const displayHeight = maxDisplayHeight;

      const oldIndicator = frameContent.querySelector('.carousel-indicators');
      if (oldIndicator) oldIndicator.remove();

      const oldArrows = frameContent.querySelectorAll('[data-arrow]');
      oldArrows.forEach(arrow => arrow.remove());

      let currentImageIndex = 0;

      if (photosToRender.length > 1) {
        const indicator = document.createElement('div');
        indicator.className = 'carousel-indicators';
        indicator.textContent = `1/${photosToRender.length}`;
        frameContent.appendChild(indicator);

        let isDragging = false;
        let startDragX = 0;
        let startScrollLeft = 0;

        const dragStart = (e) => {
          isDragging = true;
          startDragX = e.type.includes('mouse') ? e.pageX : e.touches[0].clientX;
          startScrollLeft = currentImageIndex * displayWidth;
          frameContent.style.cursor = 'grabbing';
          imagesContainer.style.transition = 'none';
        };

        const dragMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].clientX;
          const diff = startDragX - currentX;
          const newTranslate = startScrollLeft + diff;
          imagesContainer.style.transform = `translateX(-${newTranslate}px)`;
        };

        const dragEnd = (e) => {
          if (!isDragging) return;
          isDragging = false;
          frameContent.style.cursor = 'grab';

          const currentX = e.type.includes('mouse') ? e.pageX : e.changedTouches[0].clientX;
          const diff = startDragX - currentX;

          if (Math.abs(diff) > 50) {
            if (diff > 0 && currentImageIndex < photosToRender.length - 1) {
              currentImageIndex++;
            } else if (diff < 0 && currentImageIndex > 0) {
              currentImageIndex--;
            }
          }

          imagesContainer.style.transition = 'transform 0.3s ease';
          imagesContainer.style.transform = `translateX(-${currentImageIndex * displayWidth}px)`;
          indicator.textContent = `${currentImageIndex + 1}/${photosToRender.length}`;
          updateArrows();
        };

        frameContent.addEventListener('mousedown', dragStart);
        frameContent.addEventListener('mousemove', dragMove);
        frameContent.addEventListener('mouseup', dragEnd);
        frameContent.addEventListener('mouseleave', dragEnd);

        frameContent.addEventListener('touchstart', dragStart);
        frameContent.addEventListener('touchmove', dragMove);
        frameContent.addEventListener('touchend', dragEnd);

        const leftArrow = document.createElement('div');
        leftArrow.setAttribute('data-arrow', 'left');
        leftArrow.style.cssText = 'position: absolute; left: 10px; top: 50%; transform: translateY(-50%); width: 30px; height: 30px; background: rgba(0,0,0,0.5); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 10; color: white; font-size: 20px; user-select: none;';
        leftArrow.innerHTML = '‹';

        const rightArrow = document.createElement('div');
        rightArrow.setAttribute('data-arrow', 'right');
        rightArrow.style.cssText = 'position: absolute; right: 10px; top: 50%; transform: translateY(-50%); width: 30px; height: 30px; background: rgba(0,0,0,0.5); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 10; color: white; font-size: 20px; user-select: none;';
        rightArrow.innerHTML = '›';

        const navigate = (direction) => {
          if (direction === 'left' && currentImageIndex > 0) {
            currentImageIndex--;
          } else if (direction === 'right' && currentImageIndex < photosToRender.length - 1) {
            currentImageIndex++;
          }
          imagesContainer.style.transition = 'transform 0.3s ease';
          imagesContainer.style.transform = `translateX(-${currentImageIndex * displayWidth}px)`;
          indicator.textContent = `${currentImageIndex + 1}/${photosToRender.length}`;
          updateArrows();
        };

        leftArrow.onclick = (e) => { e.stopPropagation(); navigate('left'); };
        rightArrow.onclick = (e) => { e.stopPropagation(); navigate('right'); };

        const updateArrows = () => {
          leftArrow.style.display = currentImageIndex > 0 ? 'flex' : 'none';
          rightArrow.style.display = currentImageIndex < photosToRender.length - 1 ? 'flex' : 'none';
        };

        frameContent.appendChild(leftArrow);
        frameContent.appendChild(rightArrow);
        updateArrows();
      }

      photosToRender.forEach((photo) => {
        const imageDiv = document.createElement('div');
        imageDiv.className = 'post-image';

        imageDiv.style.width = displayWidth + 'px';
        imageDiv.style.height = displayHeight + 'px';

        let paddingLeft = marginPx;
        let paddingRight = marginPx;
        let paddingTop = marginPx;
        let paddingBottom = marginPx;

        if (photo.isSplitLeft) {
            paddingRight = 0;
        } else if (photo.isSplitRight) {
            paddingLeft = 0;
        }

        imageDiv.style.padding = `${paddingTop}px ${paddingRight}px ${paddingBottom}px ${paddingLeft}px`;

        const availableWidth = displayWidth - (paddingLeft + paddingRight);
        const availableHeight = displayHeight - (paddingTop + paddingBottom);

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        const img = new Image();
        img.onload = () => {
          canvas.width = availableWidth;
          canvas.height = availableHeight;

          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          if (photo.isSplitLeft || photo.isSplitRight) {
            const sourceX = photo.isSplitLeft ? 0 : img.width / 2;
            const sourceWidth = img.width / 2;
            const sourceHeight = img.height;

            const scale = Math.max(availableWidth / sourceWidth, availableHeight / sourceHeight);
            const scaledWidth = sourceWidth * scale;
            const scaledHeight = sourceHeight * scale;
            const offsetX = (availableWidth - scaledWidth) / 2;
            const offsetY = (availableHeight - scaledHeight) / 2;

            ctx.drawImage(img, sourceX, 0, sourceWidth, sourceHeight, offsetX, offsetY, scaledWidth, scaledHeight);
          } else if (photo.isLandscape && currentFormat !== 'story') {
            const scale = Math.min(availableWidth / img.width, availableHeight / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const offsetX = (availableWidth - scaledWidth) / 2;
            const offsetY = (availableHeight - scaledHeight) / 2;
            ctx.drawImage(img, 0, 0, img.width, img.height, offsetX, offsetY, scaledWidth, scaledHeight);
          } else {
            const scale = Math.max(availableWidth / img.width, availableHeight / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const offsetX = (availableWidth - scaledWidth) / 2;
            const offsetY = (availableHeight - scaledHeight) / 2;
            ctx.drawImage(img, 0, 0, img.width, img.height, offsetX, offsetY, scaledWidth, scaledHeight);
          }

          const displayImg = document.createElement('img');
          displayImg.src = canvas.toDataURL('image/jpeg', 0.95);
          displayImg.alt = photo.name;
          displayImg.style.width = '100%';
          displayImg.style.height = '100%';
          displayImg.style.objectFit = 'contain';
          imageDiv.appendChild(displayImg);
        };
        img.src = photo.src;

        imagesContainer.appendChild(imageDiv);
      });

      imagesContainer.style.transform = `translateX(0px)`;
    }

    function renderPreview() {
      const previewGrid = document.getElementById('previewGrid');
      previewGrid.innerHTML = '';

      const totalSlots = 9;

      const format = FORMATS[currentFormat];
      const formatW = format.width;
      const formatH = format.height;

      const marginMm = parseFloat(document.getElementById('frameMargin').value);
      const marginPxMain = (marginMm / 25.4) * 96;

      const mainImageDiv = document.querySelector('#imagesContainer .post-image');
      const mainW = mainImageDiv ? mainImageDiv.clientWidth : 600;  
      const mainH = mainImageDiv ? mainImageDiv.clientHeight : 600;

      for (let i = 0; i < totalSlots; i++) {
        const cell = document.createElement('div');
        cell.className = 'preview-post';

        if (i === 0 && photos.length > 0) {
          cell.style.aspectRatio = `${formatW} / ${formatH}`;

          const wrapper = document.createElement('div');
          wrapper.style.width = '100%';
          wrapper.style.height = '100%';
          wrapper.style.boxSizing = 'border-box';

          requestAnimationFrame(() => {
            const cellWidth = cell.clientWidth;
            const marginPxCell = marginPxMain * (cellWidth / mainW);

            wrapper.style.padding = `${marginPxCell}px`;

            const img = document.createElement('img');
            img.src = photos[0].src;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';

            wrapper.appendChild(img);
            cell.appendChild(wrapper);
          });

          cell.classList.add('new-post');

        } else {
          cell.style.aspectRatio = '4 / 5';
          cell.classList.add('placeholder');
        }

        previewGrid.appendChild(cell);
      }
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    async function createPostBlob(photo, width, height) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      const baseDimsNoMargin = getPostDimensions();

      const img = await loadImage(photo.src);

      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, width, height);

      const targetAspect = baseDimsNoMargin.width / baseDimsNoMargin.height;

      let sourceX, sourceY, sourceWidth, sourceHeight;
      let drawW, drawH, drawX, drawY;

      const marginMm = parseFloat(document.getElementById('frameMargin').value);
      const marginPx = marginMm > 0 ? (marginMm / 25.4) * 1080 : 0;

      drawX = photo.isSplitRight ? 0 : marginPx;
      drawY = marginPx;
      drawW = baseDimsNoMargin.width;
      drawH = baseDimsNoMargin.height;

      if (photo.isSplitLeft || photo.isSplitRight) {
        sourceX = photo.isSplitLeft ? 0 : img.width / 2;
        sourceY = 0;
        sourceWidth = img.width / 2;
        sourceHeight = img.height;

        const sourceAspect = sourceWidth / sourceHeight;
        if (sourceAspect > targetAspect) {
          const cropWidth = sourceHeight * targetAspect;
          sourceX += (sourceWidth - cropWidth) / 2;
          sourceWidth = cropWidth;
        } else {
          const cropHeight = sourceWidth / targetAspect;
          sourceY = (sourceHeight - cropHeight) / 2;
          sourceHeight = cropHeight;
        }
      } else if (photo.isLandscape && currentFormat !== 'story') {
        sourceX = 0;
        sourceY = 0;
        sourceWidth = img.width;
        sourceHeight = img.height;

        const photoAspect = img.width / img.height;
        if (photoAspect > targetAspect) {
          drawW = baseDimsNoMargin.width;
          drawH = baseDimsNoMargin.width / photoAspect;
          drawY = marginPx + (baseDimsNoMargin.height - drawH) / 2;
        } else {
          drawH = baseDimsNoMargin.height;
          drawW = baseDimsNoMargin.height * photoAspect;
          drawX = marginPx + (baseDimsNoMargin.width - drawW) / 2;
        }
      } else {
        const photoAspect = img.width / img.height;

        if (photoAspect > targetAspect) {
          sourceHeight = img.height;
          sourceWidth = sourceHeight * targetAspect;
          sourceX = (img.width - sourceWidth) / 2;
          sourceY = 0;
        } else {
          sourceWidth = img.width;
          sourceHeight = sourceWidth / targetAspect;
          sourceX = 0;
          sourceY = (img.height - sourceHeight) / 2;
        }
      }

      ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, drawX, drawY, drawW, drawH);

      return new Promise((resolve) => {
        const quality = parseFloat(document.getElementById('quality').value);
        canvas.toBlob((blob) => resolve(blob), 'image/jpeg', quality);
      });
    }

    async function exportInstagramPosts() {
      if (photos.length === 0) return;

      const btn = document.getElementById('exportInstagramBtn');
      btn.disabled = true;
      btn.textContent = 'Eksporterer...';

      const zip = new JSZip();

      let totalFileCount = 0;

      try {
        for (let i = 0; i < photos.length; i++) {
          const photo = photos[i];

          const baseDimsNoMargin = getPostDimensions();
          let exportWidth = baseDimsNoMargin.width;
          let exportHeight = baseDimsNoMargin.height;
          const marginMm = parseFloat(document.getElementById('frameMargin').value);

          if (marginMm > 0) {
              const marginPx = (marginMm / 25.4) * 1080;
              if (photo.isSplitLeft || photo.isSplitRight) {
                  exportWidth = baseDimsNoMargin.width + marginPx;
              } else {
                  exportWidth = baseDimsNoMargin.width + 2 * marginPx;
              }
              exportHeight = baseDimsNoMargin.height + 2 * marginPx;
          }

          const blob = await createPostBlob(photo, exportWidth, exportHeight);

          let filename;
          const fileIndex = String(i + 1).padStart(2, '0');

          filename = `instagram-${currentFormat}-${fileIndex}`;

          if (photo.isSplitLeft) {
              filename += `-left.jpg`;
          } else if (photo.isSplitRight) {
              filename += `-right.jpg`;
          } else {
              filename += `.jpg`;
          }

          zip.file(filename, blob);
          totalFileCount++;
          await new Promise(r => setTimeout(r, 100));
        }

        if (totalFileCount > 0) {
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `instagram-export-${currentFormat}.zip`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

      } catch (err) {
        alert('Feil ved eksport: ' + err.message);
      } finally {
        btn.disabled = false;
        btn.textContent = 'Eksporter Innlegg (ZIP)';
      }
    }

    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>
